{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This course will cover basic concepts and design trade-offs related to programming languages. The first half of the course focuses on functions, types, scope, storage management, exceptions, and continuations. The second half covers object-oriented features and concurrency. We will conclude with a few special-topics in programming languages. The class also has a number of small labs where students get to implement some of the language features discussed in class. Section ID: 976682 Lectures: Monday Tuesday Wednesday and Thursday, 11:00-12:20PM in WLH 2113 Section: Monday and Friday, 12:30-1:20PM in WLH 2113 Piazza: https://piazza.com/ucsd/summer2019/cse1302/home Gradescope code: MVWN3X Textbook \u00b6 We will occasionally be following John Mitchell's Concepts In Programming Languages textbook and assigning reading from this book and various other online resources and papers. Some of the book chapters have been revised, we will be handing out PDFs of these chapters. Cheaper renting options for the book seem to be available online (e.g., on Amazon ). If you are serious about programming languages Benjamin Pierce's Types and Programming Languages is a must. Course Staff \u00b6 Instructor: Kaiser Pister TAs: Kishore, Kiana, Dongyao","title":"About"},{"location":"#textbook","text":"We will occasionally be following John Mitchell's Concepts In Programming Languages textbook and assigning reading from this book and various other online resources and papers. Some of the book chapters have been revised, we will be handing out PDFs of these chapters. Cheaper renting options for the book seem to be available online (e.g., on Amazon ). If you are serious about programming languages Benjamin Pierce's Types and Programming Languages is a must.","title":"Textbook"},{"location":"#course-staff","text":"Instructor: Kaiser Pister TAs: Kishore, Kiana, Dongyao","title":"Course Staff"},{"location":"about/","text":"The course consists of lectures, written homeworks, and programming labs. The goal of the course is to (1) familiarize you with various modern programming language concepts and paradigms and (2) get you to think about and understand the design trade-offs and implementations of different language features. We will use real-world languages (e.g., JavaScript, Haskell, C++, and Rust) to explore the different concepts. But, we will not cover any one language in full -- this course is not meant to make you a proficient programmer, learning how to proficiently program in any of these languages is a course in and of itself. Grading \u00b6 5% Participation in class and online 50% Homeworks and programming labs 20% Midterm exam 30% Final exam Participation/pre-lecture readings \u00b6 Before each class there will be some assigned reading. You are expected to do the reading and have at least a vague understanding of the concepts that will be discussed in class. This will allow us to spend the lecture time to solidify your understanding. Asking and answering questions in class, on Piazza, or during office hours counts towards your class participation. Homework and programming labs \u00b6 We will have written homework assignments and programming labs. Both are meant to both reinforce your knowledge of the concepts covered in lecture and get you to think about PL in more depth, beyond what is covered lecture (e.g., if you were tasked with designing a new language). You are expected to work on written assignments in groups of 3. All written homework must be typeset and submitted as a PDF using the online submission tool. All written assignments must be submitted as a group. Homeworks will be released Sunday and will be due the following Saturday night (7 days) (with the exception of homework 5, which is due the Thursday after release). If you turn it in early -- the following Thursday (5 days) -- you will receive an additional 10% of your grade. There are no late days. You are expected to work on the programming labs by yourself. You may discuss the assignments with students from the course, in general, but not any specific solution. Programming assignments will be released as shown on the syllabus page. If you turn them in early you will receive an additional 10% of your grade. There are no late days. If you consult anything (books, academic papers, internet resources, people not in your group) when working on the assignments, note this in your submission. We encourage outside learning but expect you to not seek out specific details about a solution -- anything submitted should be considered your own work. Similarly, you are expected to not publish or otherwise share your solutions at any point (even after the class is over). If you are unsure about what is allowed, please ask the course staff. We will have a 5 written homeworks and 3 programming labs. They equally count towards 50% of your grade. Tentative release dates for assignments \u00b6 All assignments and solutions will be posted on Piazza. All are to be turned in via gradescope. We will be releasing them on the following dates: Written homeworks : Aug 4, Aug 11, Aug 18, Aug 25, Sept 1 Programming Assignments : Aug 4, July 7, Skip Week, July 21 Exams \u00b6 The midterm exam will be held on August 20th , in class. The midterm is closed-book , but you may use a double-sided cheat sheet (letter-size). The final exam will be held on September 7, in TBD from 11:30AM-2:29PM. You must take the exam at this time and location. The final is closed-book , but you may use 2 double-sided cheat sheets (letter-size). The exams will make up 50% of your grade. Since the final is cumulative your midterm grade will be calculated as: midterm > 0 ? max(final, midterm) : 0 This means that (1) you basically get a second chance if you don't so well on the midterm and (2) you must show up to both the midterm and the final. If you need to miss either exam because of a documented medical emergency, contact the instructor immediately. Academic integrity and student conduct \u00b6 By taking this course, you implicitly agree to abide by the UCSD policies on Integrity of Scholarship and Student Conduct . University rules on integrity of scholarship and code of conduct are taken seriously and will be enforced.","title":"Organization"},{"location":"about/#grading","text":"5% Participation in class and online 50% Homeworks and programming labs 20% Midterm exam 30% Final exam","title":"Grading"},{"location":"about/#participationpre-lecture-readings","text":"Before each class there will be some assigned reading. You are expected to do the reading and have at least a vague understanding of the concepts that will be discussed in class. This will allow us to spend the lecture time to solidify your understanding. Asking and answering questions in class, on Piazza, or during office hours counts towards your class participation.","title":"Participation/pre-lecture readings"},{"location":"about/#homework-and-programming-labs","text":"We will have written homework assignments and programming labs. Both are meant to both reinforce your knowledge of the concepts covered in lecture and get you to think about PL in more depth, beyond what is covered lecture (e.g., if you were tasked with designing a new language). You are expected to work on written assignments in groups of 3. All written homework must be typeset and submitted as a PDF using the online submission tool. All written assignments must be submitted as a group. Homeworks will be released Sunday and will be due the following Saturday night (7 days) (with the exception of homework 5, which is due the Thursday after release). If you turn it in early -- the following Thursday (5 days) -- you will receive an additional 10% of your grade. There are no late days. You are expected to work on the programming labs by yourself. You may discuss the assignments with students from the course, in general, but not any specific solution. Programming assignments will be released as shown on the syllabus page. If you turn them in early you will receive an additional 10% of your grade. There are no late days. If you consult anything (books, academic papers, internet resources, people not in your group) when working on the assignments, note this in your submission. We encourage outside learning but expect you to not seek out specific details about a solution -- anything submitted should be considered your own work. Similarly, you are expected to not publish or otherwise share your solutions at any point (even after the class is over). If you are unsure about what is allowed, please ask the course staff. We will have a 5 written homeworks and 3 programming labs. They equally count towards 50% of your grade.","title":"Homework and programming labs"},{"location":"about/#tentative-release-dates-for-assignments","text":"All assignments and solutions will be posted on Piazza. All are to be turned in via gradescope. We will be releasing them on the following dates: Written homeworks : Aug 4, Aug 11, Aug 18, Aug 25, Sept 1 Programming Assignments : Aug 4, July 7, Skip Week, July 21","title":"Tentative release dates for assignments"},{"location":"about/#exams","text":"The midterm exam will be held on August 20th , in class. The midterm is closed-book , but you may use a double-sided cheat sheet (letter-size). The final exam will be held on September 7, in TBD from 11:30AM-2:29PM. You must take the exam at this time and location. The final is closed-book , but you may use 2 double-sided cheat sheets (letter-size). The exams will make up 50% of your grade. Since the final is cumulative your midterm grade will be calculated as: midterm > 0 ? max(final, midterm) : 0 This means that (1) you basically get a second chance if you don't so well on the midterm and (2) you must show up to both the midterm and the final. If you need to miss either exam because of a documented medical emergency, contact the instructor immediately.","title":"Exams"},{"location":"about/#academic-integrity-and-student-conduct","text":"By taking this course, you implicitly agree to abide by the UCSD policies on Integrity of Scholarship and Student Conduct . University rules on integrity of scholarship and code of conduct are taken seriously and will be enforced.","title":"Academic integrity and student conduct"},{"location":"assignments/","text":"Here is a comprehensive list of assignments for the course. Written Assignments \u00b6 HW1 HW2 HW3 HW4 HW5 Programming Assignments \u00b6 These are zip files which will be downloaded on click. PA1 PA2 PA3 Virtual Machine \u00b6 WARNING If you use the VMs below, you MUST download the zipped pa's above and copy them onto the VM before you begin. The VMs contain outdated versions of the PAs which maybe lead to different scores on Gradescope. Consider using: scp -P 2222 -r pa1 student@localhost:~/ to copy files. Installing and setting up Haskell can be difficult on non-Un*x machines. If you prefer to use a presetup VM, you can download one from the link below. Notes: This VM is built with VirtualBox, you will need to download their VM Manager to use it. This VM is 8gb. The download itself is 1.6gb. The VM comes with Node and Haskell, as well as the pa's already downloaded and setup. To SSH into the VM run ssh -p 2222 student@127.0.0.1 while the VM is running There are two accounts: student (password: lambda) and root (password: plrocks) The PA 3 VM is identical to the original VM, but uses only GHCI instead of stack. The PA 1 and 2 VM The PA 3 VM The new VM is identical to the other VM, but uses GHCI instead of stack. ghci Calculator.hs to run etc.","title":"Main"},{"location":"assignments/#written-assignments","text":"HW1 HW2 HW3 HW4 HW5","title":"Written Assignments"},{"location":"assignments/#programming-assignments","text":"These are zip files which will be downloaded on click. PA1 PA2 PA3","title":"Programming Assignments"},{"location":"assignments/#virtual-machine","text":"WARNING If you use the VMs below, you MUST download the zipped pa's above and copy them onto the VM before you begin. The VMs contain outdated versions of the PAs which maybe lead to different scores on Gradescope. Consider using: scp -P 2222 -r pa1 student@localhost:~/ to copy files. Installing and setting up Haskell can be difficult on non-Un*x machines. If you prefer to use a presetup VM, you can download one from the link below. Notes: This VM is built with VirtualBox, you will need to download their VM Manager to use it. This VM is 8gb. The download itself is 1.6gb. The VM comes with Node and Haskell, as well as the pa's already downloaded and setup. To SSH into the VM run ssh -p 2222 student@127.0.0.1 while the VM is running There are two accounts: student (password: lambda) and root (password: plrocks) The PA 3 VM is identical to the original VM, but uses only GHCI instead of stack. The PA 1 and 2 VM The PA 3 VM The new VM is identical to the other VM, but uses GHCI instead of stack. ghci Calculator.hs to run etc.","title":"Virtual Machine"},{"location":"contact/","text":"For general information and questions, please post to the class Piazza . It's very likely that other students will have the same question. We will post announcements on Piazza, so please make sure to sign up. For urgent or personal matters, please post a private question or contact the course staff by email. Instructor \u00b6 Name: Kaiser Pister Email: kpister+cse130@eng.ucsd.edu Address: CSE 3234 Office Hours: Friday 9:00am-11:00am, (2:00pm-4:00pm starting week 2), or by appointment Teaching Assistants \u00b6 Name: Kishore Reddy Office hours: Saturdays, @ TBD, in TBD Name: Kiana Lucin Office hours: Tuesdays, 1-2pm, in B240A Name: Dongyao Zhu Office hours: Thursdays, 2-4pm, in B270","title":"Contact information"},{"location":"contact/#instructor","text":"Name: Kaiser Pister Email: kpister+cse130@eng.ucsd.edu Address: CSE 3234 Office Hours: Friday 9:00am-11:00am, (2:00pm-4:00pm starting week 2), or by appointment","title":"Instructor"},{"location":"contact/#teaching-assistants","text":"Name: Kishore Reddy Office hours: Saturdays, @ TBD, in TBD Name: Kiana Lucin Office hours: Tuesdays, 1-2pm, in B240A Name: Dongyao Zhu Office hours: Thursdays, 2-4pm, in B270","title":"Teaching Assistants"},{"location":"syllabus/","text":"Week of Monday & Tuesday Wednesday & Thursday Monday & Friday (section) Aug 05- Aug 08 JavaScript and high-order functions Lambda Calculus Lambda Calc Review Aug 12- Aug 15 Closures & Haskell Crash Course Type polymorphism and type inference Haskell Crash Course (cont.) Aug 19- Aug 22 Catch-up / Review & Midterm Type classes and Garbage Collection Midterm Review (Monday section) Aug 26- Aug 29 Objects vtables, subtyping, inheritance C++ Review Sep 02- Sep 05 Holiday & Control Flow, Continuations PL Topics & Final Review Additional Final Review Sep 07 Final Tenative release dates for assignments: \u00b6 Written homeworks : Aug 4 , Aug 11 , Aug 18 , Aug 25 , Sept 1 Programming Assignments : Aug 4 , Aug 15 , Aug 25","title":"Syllabus"},{"location":"syllabus/#tenative-release-dates-for-assignments","text":"Written homeworks : Aug 4 , Aug 11 , Aug 18 , Aug 25 , Sept 1 Programming Assignments : Aug 4 , Aug 15 , Aug 25","title":"Tenative release dates for assignments:"},{"location":"assn/Tokenizer/","text":"Tokenizer \u00b6 This part of the assignment is more freeform than the other PA's. Your task is to create the first piece of a compiler pipeline for a language of your choosing (including a language which you design). A tokenizer can loosely be written as a function f :: Token a => File -> [a] This program can be written in any language you choose. Ideas \u00b6 To give some contextual ideas a subset of the tokens used in C would include { Identifier, Left Bracket, Right Bracket, Int, Char, IF, ASSIGN, Int Literal } For reference, C has a total of over 40 different possible tokens. Given a C file such as int main() { int a = 3; return a; } The ideal tokenization would be: [INT, IDENTIFIER, LEFT PARENS, RIGHT PARENS, LEFT BRACKET, INT, IDENTIFIER, ASSIGN, INT LITERAL, SEMICOLON, RETURN, IDENTIFIER, SEMICOLON, RIGHT BRACKET, EOF] You have free reign over the language you are tokenizing, I would recommend something simpler than C. A potentially simple one to do would be Lambda Calculus. Grading \u00b6 We will grade largely on effort put into the project, however we also expect to be able to run your tokenizer on a few sample files of the language it reads. In your Gradescope submission, please include at least 3 files which your tokenizer can parse, as well as a README file as described below. Required README: \u00b6 Please include with your tokenizer a README.md file which answers the following questions: What language is your tokenizer written in? What language are you tokenizing? How do you run your tokenizer? What is the output format of your tokenizer? What sorts of errors can your tokenizer handle? Notes \u00b6 PL is often the precursor to Compilers (CSE 131) because the ideas that we discuss in class make their way into languages through a compiler. Compilers are often divided into 4 key parts: Lexer (tokenizer), Parser, Semantic Analysis, Code Generation. With this start, I encourage you to try building the next stages for your language as well! This document will continue to grow over the next few weeks. Check back online for updated versions with more advice. Guide \u00b6 If you are looking for some advice on how to start your project, see below. Otherwise this can be ignored. Step 1. Make Choices \u00b6 Choose a language you want to write your code in, my go to choice is Python, but for a language task Haskell might be perfect. Next choose or create a language you want to parse. This step could take a while. Feel free to google around for esoteric languages like Brainf*ck, or use something we covered like uHaskell or Lambda Calculus. If you want to create a language, start by creating a subset of a current language: uGo for example. Step 2. Establish the Lexicon \u00b6 Compile a list of each token that could exist in your language. These are things like identifiers, brackets, the primative times, etc. Some languages have a lot! Step 3. Write the Lexer \u00b6 Write some code to parse a file, generally splitting on whitespace (though that doesn't work for whitespace ). With each token, figure out what part of the lexicon it might be, and add that to your list. Step 4. Celebrate! [Optional] \u00b6 Step 5. Build a Parser. [Optional, extra credit??] \u00b6 Once you have a list of the source code tokens, you can start to parse them into expressions. This step requires further independent research.","title":"Tokenizer.md"},{"location":"assn/Tokenizer/#tokenizer","text":"This part of the assignment is more freeform than the other PA's. Your task is to create the first piece of a compiler pipeline for a language of your choosing (including a language which you design). A tokenizer can loosely be written as a function f :: Token a => File -> [a] This program can be written in any language you choose.","title":"Tokenizer"},{"location":"assn/Tokenizer/#ideas","text":"To give some contextual ideas a subset of the tokens used in C would include { Identifier, Left Bracket, Right Bracket, Int, Char, IF, ASSIGN, Int Literal } For reference, C has a total of over 40 different possible tokens. Given a C file such as int main() { int a = 3; return a; } The ideal tokenization would be: [INT, IDENTIFIER, LEFT PARENS, RIGHT PARENS, LEFT BRACKET, INT, IDENTIFIER, ASSIGN, INT LITERAL, SEMICOLON, RETURN, IDENTIFIER, SEMICOLON, RIGHT BRACKET, EOF] You have free reign over the language you are tokenizing, I would recommend something simpler than C. A potentially simple one to do would be Lambda Calculus.","title":"Ideas"},{"location":"assn/Tokenizer/#grading","text":"We will grade largely on effort put into the project, however we also expect to be able to run your tokenizer on a few sample files of the language it reads. In your Gradescope submission, please include at least 3 files which your tokenizer can parse, as well as a README file as described below.","title":"Grading"},{"location":"assn/Tokenizer/#required-readme","text":"Please include with your tokenizer a README.md file which answers the following questions: What language is your tokenizer written in? What language are you tokenizing? How do you run your tokenizer? What is the output format of your tokenizer? What sorts of errors can your tokenizer handle?","title":"Required README:"},{"location":"assn/Tokenizer/#notes","text":"PL is often the precursor to Compilers (CSE 131) because the ideas that we discuss in class make their way into languages through a compiler. Compilers are often divided into 4 key parts: Lexer (tokenizer), Parser, Semantic Analysis, Code Generation. With this start, I encourage you to try building the next stages for your language as well! This document will continue to grow over the next few weeks. Check back online for updated versions with more advice.","title":"Notes"},{"location":"assn/Tokenizer/#guide","text":"If you are looking for some advice on how to start your project, see below. Otherwise this can be ignored.","title":"Guide"},{"location":"assn/Tokenizer/#step-1-make-choices","text":"Choose a language you want to write your code in, my go to choice is Python, but for a language task Haskell might be perfect. Next choose or create a language you want to parse. This step could take a while. Feel free to google around for esoteric languages like Brainf*ck, or use something we covered like uHaskell or Lambda Calculus. If you want to create a language, start by creating a subset of a current language: uGo for example.","title":"Step 1. Make Choices"},{"location":"assn/Tokenizer/#step-2-establish-the-lexicon","text":"Compile a list of each token that could exist in your language. These are things like identifiers, brackets, the primative times, etc. Some languages have a lot!","title":"Step 2. Establish the Lexicon"},{"location":"assn/Tokenizer/#step-3-write-the-lexer","text":"Write some code to parse a file, generally splitting on whitespace (though that doesn't work for whitespace ). With each token, figure out what part of the lexicon it might be, and add that to your list.","title":"Step 3. Write the Lexer"},{"location":"assn/Tokenizer/#step-4-celebrate-optional","text":"","title":"Step 4. Celebrate! [Optional]"},{"location":"assn/Tokenizer/#step-5-build-a-parser-optional-extra-credit","text":"Once you have a list of the source code tokens, you can start to parse them into expressions. This step requires further independent research.","title":"Step 5. Build a Parser. [Optional, extra credit??]"},{"location":"discussions/week1/","text":"JavaScript fundamentals revisited by Purag Moumdjian \u00b6 Below are the notes from the discussion section. The global object \u00b6 In Node.js, the global object contains functions (and lots of other information) exposed by the runtime environment. By default, this in the top-level scope of a node module refers to the module itself. When not in strict mode, this inside a function is automatically assigned the global object. // global object console . log ( this === global ); // ?? { console . log ( this === global ); // ?? } function f () { console . log ( this === global ); } f (); // ?? new f (); // ?? ( function () { \"use strict\" ; console . log ( this === global ); // ?? })(); Receivers/the this keyword \u00b6 We can dynamically change the value of this when executing a function which uses it. All functions in JavaScript have three methods which let us do this: call , apply , and bind . call and apply immediately invoke the function with the specified receiver (target object) and arguments. bind creates a new function with the receiver (and any provided arguments) bound to the specified values. This lets us create clones of functions where the this keyword always refers to a specific object (see swapObj2 below). bind also lets us accomplish partial application of functions, meaning we can create copies of functions with some (or all) of the arguments already fixed. We'll revisit this in detail throughout the quarter. // objects + this let obj = { x : 1 , y : 2 , swap : function () { let temp = this . x ; this . x = this . y ; this . y = temp ; } }; console . log ( obj . x , obj . y ); // ?? obj . swap (); console . log ( obj . x , obj . y ); // ?? let obj2 = { x : 3 , y : 4 } console . log ( obj2 . x , obj2 . y ); // ?? obj . swap . call ( obj2 ); console . log ( obj2 . x , obj2 . y ); // ?? console . log ( obj . x , obj . y ); // ?? swapObj2 = obj . swap . bind ( obj2 ); swapObj2 (); console . log ( obj2 . x , obj2 . y ); // ?? swapObj2 (); console . log ( obj2 . x , obj2 . y ); // ?? // Also works with regular functions (not belonging to an object)... function f () { console . log ( this . x , this . y ); } f . call ( obj2 ); console . log ( obj2 . x , obj2 . y ); // ?? // And also works with arguments... function g ( arg1 ) { console . log ( this . x , this . y , arg1 ); } g . call ( obj2 , \"argument 1\" ); // ? Classes/Function constructors \u00b6 Before classes were native to JavaScript, we would use plain old functions to construct objects. These are called function constructors . When we invoke any function with the new keyword (i.e. new Car() ), this is automatically bound to a newly created object (whose prototype __proto__ is Car.prototype ), allowing us to specify instance data attached to this inside a function constructor. Since functions create a new scope in JavaScript, and since JavaScript functions are closures, we can create \"hidden\"/private fields and methods just by declaring local variables and functions. These are only visible in the scope of the function, and because functions are closures and capture the environment, these \"fields\" and \"methods\" can be accessed even after the object is created. One caveat is that each instance of the object will have its own copy of every private method, and if you want a public method that uses a private method, each object needs a copy of that, too -- the public method will have to share the scope of the private method. This is not the way you want to manage private field, it's just an illustration. See this blog post for a discussion. // classes + function constructors let Car = function ( make , model ) { this . make = make ; this . model = model ; }; let car1 = new Car ( \"toyota\" , \"camry\" ); console . log ( car1 . make , car1 . model ); // ?? // We can even make private fields! Car = function ( make , model , year ) { let private_year = year ; this . make = make ; this . model = model ; } let car2 = new Car ( \"honda\" , \"civic\" , 2018 ) console . log ( car2 . make , car2 . model ); // ?? console . log ( car2 . private_year ); // ?? console . log ( car2 . year ); // ?? // Private methods? Car = function ( make , model , year ) { let private_year = year ; this . make = make ; this . model = model ; function private_getInternalLabel () { return ` ${ make } @ ${ model } ` ; } this . toString = function () { return ` ${ private_getInternalLabel () } @ ${ private_year } ` }; } let car3 = new Car ( \"ford\" , \"edge\" , 2018 ); console . log ( car3 . private_getInternalLabel ()); // ?? console . log ( car3 . toString ()); // ?? Hoisting \u00b6 JavaScript hoists var declaration and function declarations and definitions to the top of the current scope. This behavior may or not be desired, but if you want to avoid it, just use let and const to declare variables, as they are not hoisted -- in other words, they create a new scope only once they executed, and these scopes end as soon as the surrounding block ends. // hoisting { console . log ( undeclared ); // ?? } { console . log ( let_declared_later ); // ?? let let_declared_later ; } { console . log ( var_declared_later ); // ?? var var_declared_later ; } { console . log ( defined_later ()); // ?? function defined_later () { return \"yay!\" ; } } { console . log ( let_defined_later ()); // ?? let let_defined_later = function () { return \"yay!\" ; }; } Functions/Callbacks/Arrow Notation \u00b6 Below, we have a function constructor for Car , and in the constructor we create methods getMake and getModel which access the arguments of the function. We return the new object to the caller and the function's scope ends, but subsequent calls to getMake and getModel will still have access to the arguments from the function's scope due to closure. For another example, see Closure // functions + closures function f () { return 0 ; } console . log ( typeof f ); // ?? console . log ( f instanceof Object ); // ?? console . log ( f . toString ()); // ?? // Back to function constructors let Car = function ( make , model ) { this . getMake = function () { return make ; }; this . getModel = function () { return model ; }; } let car1 = new Car ( \"toyota\" , \"camry\" ); console . log ( car1 . getMake (), car1 . getModel ()); // ?? // Arrow notation: more concise, especially with callbacks const g = () => { return 0 ; }; console . log ( g ()); // ?? setTimeout (() => { console . log ( \"done\" ); }, 10 ); // More examples of this in 06.functional.js... List Manipulation a la Functional Programming in JavaScript \u00b6 map , reduce (or fold ), and filter are three examples of list manipulation functions. Recursion is the bread and butter of functional programming, and these functions are prime examples. JavaScript arrays natively support some of these behaviors, as seen below. // functional stuff! const array = [ 1 , 2 , 3 ]; let newArray = array . map (( x ) => x + 1 ); console . log ( newArray ); // ?? newArray = array . reduce (( accum , x ) => accum + x , 0 ); console . log ( newArray ); // ?? newArray = array . filter (( x ) => x <= 2 ); console . log ( newArray ); // ?? newArray = array . filter (( x ) => x > 2 ); console . log ( newArray ); // ?? Closure \u00b6 Below are some classical examples of closures. // Closure example // #1 { var funcs = []; for ( var i = 0 ; i < 10 ; i ++ ) { funcs . push ( function () { console . log ( i ); }); } funcs . forEach ( function ( func ) { func (); }); } // #2 { let i = 5 ; const f = () => console . log ( i ); f (); // ?? i = 10 ; f (); // ?? } // #3 // How do we fix the problem in #1? { let funcs = []; for ( let i = 0 ; i < 10 ; i ++ ) { funcs . push (() => console . log ( i )); } funcs . forEach (( func ) => func ()); } // #4 // How can we fix it without using let? (Also, how did we fix this before let?) { var funcs = []; for ( var i = 0 ; i < 10 ; i ++ ) { funcs . push (( function ( j ) { return function () { console . log ( j ); } })( i )); } funcs . forEach ( function ( func ) { func (); }); // or... funcs = []; for ( var i = 0 ; i < 10 ; i ++ ) { funcs . push ( function ( j ) { console . log ( j ); }. bind ( null , i )); } funcs . forEach ( function ( func ) { func (); }); }","title":"Week 1"},{"location":"discussions/week1/#javascript-fundamentals-revisited-by-purag-moumdjian","text":"Below are the notes from the discussion section.","title":"JavaScript fundamentals revisited by Purag Moumdjian"},{"location":"discussions/week1/#the-global-object","text":"In Node.js, the global object contains functions (and lots of other information) exposed by the runtime environment. By default, this in the top-level scope of a node module refers to the module itself. When not in strict mode, this inside a function is automatically assigned the global object. // global object console . log ( this === global ); // ?? { console . log ( this === global ); // ?? } function f () { console . log ( this === global ); } f (); // ?? new f (); // ?? ( function () { \"use strict\" ; console . log ( this === global ); // ?? })();","title":"The global object"},{"location":"discussions/week1/#receiversthe-this-keyword","text":"We can dynamically change the value of this when executing a function which uses it. All functions in JavaScript have three methods which let us do this: call , apply , and bind . call and apply immediately invoke the function with the specified receiver (target object) and arguments. bind creates a new function with the receiver (and any provided arguments) bound to the specified values. This lets us create clones of functions where the this keyword always refers to a specific object (see swapObj2 below). bind also lets us accomplish partial application of functions, meaning we can create copies of functions with some (or all) of the arguments already fixed. We'll revisit this in detail throughout the quarter. // objects + this let obj = { x : 1 , y : 2 , swap : function () { let temp = this . x ; this . x = this . y ; this . y = temp ; } }; console . log ( obj . x , obj . y ); // ?? obj . swap (); console . log ( obj . x , obj . y ); // ?? let obj2 = { x : 3 , y : 4 } console . log ( obj2 . x , obj2 . y ); // ?? obj . swap . call ( obj2 ); console . log ( obj2 . x , obj2 . y ); // ?? console . log ( obj . x , obj . y ); // ?? swapObj2 = obj . swap . bind ( obj2 ); swapObj2 (); console . log ( obj2 . x , obj2 . y ); // ?? swapObj2 (); console . log ( obj2 . x , obj2 . y ); // ?? // Also works with regular functions (not belonging to an object)... function f () { console . log ( this . x , this . y ); } f . call ( obj2 ); console . log ( obj2 . x , obj2 . y ); // ?? // And also works with arguments... function g ( arg1 ) { console . log ( this . x , this . y , arg1 ); } g . call ( obj2 , \"argument 1\" ); // ?","title":"Receivers/the this keyword"},{"location":"discussions/week1/#classesfunction-constructors","text":"Before classes were native to JavaScript, we would use plain old functions to construct objects. These are called function constructors . When we invoke any function with the new keyword (i.e. new Car() ), this is automatically bound to a newly created object (whose prototype __proto__ is Car.prototype ), allowing us to specify instance data attached to this inside a function constructor. Since functions create a new scope in JavaScript, and since JavaScript functions are closures, we can create \"hidden\"/private fields and methods just by declaring local variables and functions. These are only visible in the scope of the function, and because functions are closures and capture the environment, these \"fields\" and \"methods\" can be accessed even after the object is created. One caveat is that each instance of the object will have its own copy of every private method, and if you want a public method that uses a private method, each object needs a copy of that, too -- the public method will have to share the scope of the private method. This is not the way you want to manage private field, it's just an illustration. See this blog post for a discussion. // classes + function constructors let Car = function ( make , model ) { this . make = make ; this . model = model ; }; let car1 = new Car ( \"toyota\" , \"camry\" ); console . log ( car1 . make , car1 . model ); // ?? // We can even make private fields! Car = function ( make , model , year ) { let private_year = year ; this . make = make ; this . model = model ; } let car2 = new Car ( \"honda\" , \"civic\" , 2018 ) console . log ( car2 . make , car2 . model ); // ?? console . log ( car2 . private_year ); // ?? console . log ( car2 . year ); // ?? // Private methods? Car = function ( make , model , year ) { let private_year = year ; this . make = make ; this . model = model ; function private_getInternalLabel () { return ` ${ make } @ ${ model } ` ; } this . toString = function () { return ` ${ private_getInternalLabel () } @ ${ private_year } ` }; } let car3 = new Car ( \"ford\" , \"edge\" , 2018 ); console . log ( car3 . private_getInternalLabel ()); // ?? console . log ( car3 . toString ()); // ??","title":"Classes/Function constructors"},{"location":"discussions/week1/#hoisting","text":"JavaScript hoists var declaration and function declarations and definitions to the top of the current scope. This behavior may or not be desired, but if you want to avoid it, just use let and const to declare variables, as they are not hoisted -- in other words, they create a new scope only once they executed, and these scopes end as soon as the surrounding block ends. // hoisting { console . log ( undeclared ); // ?? } { console . log ( let_declared_later ); // ?? let let_declared_later ; } { console . log ( var_declared_later ); // ?? var var_declared_later ; } { console . log ( defined_later ()); // ?? function defined_later () { return \"yay!\" ; } } { console . log ( let_defined_later ()); // ?? let let_defined_later = function () { return \"yay!\" ; }; }","title":"Hoisting"},{"location":"discussions/week1/#functionscallbacksarrow-notation","text":"Below, we have a function constructor for Car , and in the constructor we create methods getMake and getModel which access the arguments of the function. We return the new object to the caller and the function's scope ends, but subsequent calls to getMake and getModel will still have access to the arguments from the function's scope due to closure. For another example, see Closure // functions + closures function f () { return 0 ; } console . log ( typeof f ); // ?? console . log ( f instanceof Object ); // ?? console . log ( f . toString ()); // ?? // Back to function constructors let Car = function ( make , model ) { this . getMake = function () { return make ; }; this . getModel = function () { return model ; }; } let car1 = new Car ( \"toyota\" , \"camry\" ); console . log ( car1 . getMake (), car1 . getModel ()); // ?? // Arrow notation: more concise, especially with callbacks const g = () => { return 0 ; }; console . log ( g ()); // ?? setTimeout (() => { console . log ( \"done\" ); }, 10 ); // More examples of this in 06.functional.js...","title":"Functions/Callbacks/Arrow Notation"},{"location":"discussions/week1/#list-manipulation-a-la-functional-programming-in-javascript","text":"map , reduce (or fold ), and filter are three examples of list manipulation functions. Recursion is the bread and butter of functional programming, and these functions are prime examples. JavaScript arrays natively support some of these behaviors, as seen below. // functional stuff! const array = [ 1 , 2 , 3 ]; let newArray = array . map (( x ) => x + 1 ); console . log ( newArray ); // ?? newArray = array . reduce (( accum , x ) => accum + x , 0 ); console . log ( newArray ); // ?? newArray = array . filter (( x ) => x <= 2 ); console . log ( newArray ); // ?? newArray = array . filter (( x ) => x > 2 ); console . log ( newArray ); // ??","title":"List Manipulation a la Functional Programming in JavaScript"},{"location":"discussions/week1/#closure","text":"Below are some classical examples of closures. // Closure example // #1 { var funcs = []; for ( var i = 0 ; i < 10 ; i ++ ) { funcs . push ( function () { console . log ( i ); }); } funcs . forEach ( function ( func ) { func (); }); } // #2 { let i = 5 ; const f = () => console . log ( i ); f (); // ?? i = 10 ; f (); // ?? } // #3 // How do we fix the problem in #1? { let funcs = []; for ( let i = 0 ; i < 10 ; i ++ ) { funcs . push (() => console . log ( i )); } funcs . forEach (( func ) => func ()); } // #4 // How can we fix it without using let? (Also, how did we fix this before let?) { var funcs = []; for ( var i = 0 ; i < 10 ; i ++ ) { funcs . push (( function ( j ) { return function () { console . log ( j ); } })( i )); } funcs . forEach ( function ( func ) { func (); }); // or... funcs = []; for ( var i = 0 ; i < 10 ; i ++ ) { funcs . push ( function ( j ) { console . log ( j ); }. bind ( null , i )); } funcs . forEach ( function ( func ) { func (); }); }","title":"Closure"},{"location":"discussions/week2/","text":"Lambda Calc Review and Practice by Nadah Feteih \u00b6 Below are some notes taken from lecture and slides. We wont be posting the solutions to the practice problems we went through in discussion, but come to office hours if you have any questions. Syntax \u00b6 e ::= x | (e e) | (\u03bbx.e) Variables, applications, lambda abstractions Faking multi-argument functions. Is \u03bbx.\u03bby.\u03bbz.e the same as \u03bbxyz.e ? No, why not. See: ( x , y , z ) => {} /* same as: */ ( x ) => ( y ) => ( z ) => {} /* ? */ Syntax \u00b6 Function applications are left associative e1 e2 e3 e4 = (((e1 e2) e3) e4) Parenthesis have no meanings, you can add them as much as you want following the correct rules. (Applications are left associative and terms are bound as far right as possible) You can only drop parenthesis if the meaning isn't ambiguous. Semantics \u00b6 (\u03bbx.(\u03bby.(x + y))) 4 5 which arguments do we apply first? Free and bound variables Capture avoiding substitution ... y[x := e] = y (e1 e2)[x := e] = e1[x := e] e2[x := e] (\u03bbx.e1)[x := e] = \u03bbx.e1 ... Alpha renaming \u03bbx.e = \u03bby.e[x :=y], y != FV(e) Beta reduction (\u03bbx.e1)e2 = e1[x := e2] Eta reduction \u03bbx. e x = e , x != FV(e) Evaluation Order (CBV and CBN) \u00b6 Does it matter which order you choose to simplify subexpressions IF it reduces to normal form? What does normal form mean? Can no longer beta reduce. Some terms cannot be reduced to normal form. For example, (\u03bbx.y)\u03a9 ----> y CBN ----> (\u03bbx.y)\u03a9 CBV Practice Problems \u00b6 What doe the following produce? const Y = f => ( x => f ( x ( x )))( x => f ( x ( x ))) Y ( z => 9 ) (\u03bbx.x) (\u03bby.x y z) - what are the free variables? Reduce the following ((\u03bbx.(x y))(\u03bbz.z)) (\u03bbx.x)((\u03bby.y) z) (\u03bbf.\u03bbx.(f x)) \u03bby.y+1 (\u03bbx.\u03bby.x y)(\u03bbz.z) ((\u03bbf.(\u03bbx.f (f x)))(\u03bbx.x+1)) 4 (\u03bbf.(\u03bbx.f(f x)))(\u03bby.y+x) (\u03bbx.y)((\u03bbx.x x)(\u03bby.y z)) (\u03bbp.\u03bbq.\u03bbr.p q r)(\u03bbp.\u03bbq.p q r) ((\u03bbf.((\u03bbg.((f f) g))(\u03bbh.(k h))))(\u03bbx.(\u03bby.y)))` Evaluation Strategies - Reduce with CBV & CBN (\u03bbx.\u03bby.y x)(5 + 2)(\u03bbx.x+1) (\u03bbf.f 7)((\u03bbx.x x) \u03bby.y)","title":"Week 2"},{"location":"discussions/week2/#lambda-calc-review-and-practice-by-nadah-feteih","text":"Below are some notes taken from lecture and slides. We wont be posting the solutions to the practice problems we went through in discussion, but come to office hours if you have any questions.","title":"Lambda Calc Review and Practice by Nadah Feteih"},{"location":"discussions/week2/#syntax","text":"e ::= x | (e e) | (\u03bbx.e) Variables, applications, lambda abstractions Faking multi-argument functions. Is \u03bbx.\u03bby.\u03bbz.e the same as \u03bbxyz.e ? No, why not. See: ( x , y , z ) => {} /* same as: */ ( x ) => ( y ) => ( z ) => {} /* ? */","title":"Syntax"},{"location":"discussions/week2/#syntax_1","text":"Function applications are left associative e1 e2 e3 e4 = (((e1 e2) e3) e4) Parenthesis have no meanings, you can add them as much as you want following the correct rules. (Applications are left associative and terms are bound as far right as possible) You can only drop parenthesis if the meaning isn't ambiguous.","title":"Syntax"},{"location":"discussions/week2/#semantics","text":"(\u03bbx.(\u03bby.(x + y))) 4 5 which arguments do we apply first? Free and bound variables Capture avoiding substitution ... y[x := e] = y (e1 e2)[x := e] = e1[x := e] e2[x := e] (\u03bbx.e1)[x := e] = \u03bbx.e1 ... Alpha renaming \u03bbx.e = \u03bby.e[x :=y], y != FV(e) Beta reduction (\u03bbx.e1)e2 = e1[x := e2] Eta reduction \u03bbx. e x = e , x != FV(e)","title":"Semantics"},{"location":"discussions/week2/#evaluation-order-cbv-and-cbn","text":"Does it matter which order you choose to simplify subexpressions IF it reduces to normal form? What does normal form mean? Can no longer beta reduce. Some terms cannot be reduced to normal form. For example, (\u03bbx.y)\u03a9 ----> y CBN ----> (\u03bbx.y)\u03a9 CBV","title":"Evaluation Order (CBV and CBN)"},{"location":"discussions/week2/#practice-problems","text":"What doe the following produce? const Y = f => ( x => f ( x ( x )))( x => f ( x ( x ))) Y ( z => 9 ) (\u03bbx.x) (\u03bby.x y z) - what are the free variables? Reduce the following ((\u03bbx.(x y))(\u03bbz.z)) (\u03bbx.x)((\u03bby.y) z) (\u03bbf.\u03bbx.(f x)) \u03bby.y+1 (\u03bbx.\u03bby.x y)(\u03bbz.z) ((\u03bbf.(\u03bbx.f (f x)))(\u03bbx.x+1)) 4 (\u03bbf.(\u03bbx.f(f x)))(\u03bby.y+x) (\u03bbx.y)((\u03bbx.x x)(\u03bby.y z)) (\u03bbp.\u03bbq.\u03bbr.p q r)(\u03bbp.\u03bbq.p q r) ((\u03bbf.((\u03bbg.((f f) g))(\u03bbh.(k h))))(\u03bbx.(\u03bby.y)))` Evaluation Strategies - Reduce with CBV & CBN (\u03bbx.\u03bby.y x)(5 + 2)(\u03bbx.x+1) (\u03bbf.f 7)((\u03bbx.x x) \u03bby.y)","title":"Practice Problems"},{"location":"discussions/week4/","text":"Week 4 Discussion \u00b6 Here is the code we went over in discussion. #include <iostream> #include <string> class Animal { public : int name = 0 ; virtual void sleep () { std :: cout << \"sleeping...zzz\" << '\\n' ; } }; class Dog : public Animal { public : // change this to virtual int dogname = - 1 ; virtual void sleep () { std :: cout << \"a dog is sleeping...zzz\" << '\\n' ; } void bark () { std :: cout << \"bark bark\" << '\\n' ; } }; int main () { // will this work? dog_to_animal -> bark (); //__Animal_bark() // non-virtual sleep dog_to_animal -> sleep (); // __Animal_sleep() //Animal* dog_to_animal = new Dog(); //std::cout << dog_to_animal->dogname << '\\n'; // will this work? --subtyping Dog * animal_to_dog = new Animal (); } #include <iostream> #include <string> class Shape { public : virtual double area (){ return - 1 ;} }; class Circle : public Shape { double r ; public : Circle ( double radius ) { r = radius ;} // change this to virtual double area () { return r * r * 3.14159265 ; } }; class Rectangle : public Shape { double a , b ; public : Rectangle ( double _a , double _b ) { a = _a ; b = _b ;} // change this to virtual double area () { return a * b ; } }; void calculate_area_1 ( Shape * s ) { std :: cout << s -> area () << '\\n' ; } // pass by reference void calculate_area_2 ( Shape & s ) { std :: cout << s . area () << '\\n' ; } // pass by value: create a new instance void calculate_area_3 ( Shape s ) { std :: cout << s . area () << '\\n' ; } int main () { Circle c = Circle ( 1.0 ); Rectangle r = Rectangle ( 1.0 , 1.0 ); // pass by pointer calculate_area_1 ( & c ); calculate_area_1 ( & r ); // pass by reference //calculate_area_2(c); //calculate_area_2(r); // pass by value: create a new instance //calculate_area_3(c); //calculate_area_3(r); } #include <iostream> #include <string> #include <functional> class Animal { public : int name = 0 ; void sleep (){} }; class Dog : public Animal { public : int name = 3 ; // change this to virtual void sleep (){} void bark (){} }; Animal animal_clone () { } Dog dog_clone () { } // Q: dog_clone ? animal_clone // why? void animal_sub_dog ( std :: function < Dog () > func ) { // maybe I'll call bark here // dog = func(); dog.bark(); std :: cout << \"animal_clone is a subtype of dog_clone\" << '\\n' ; } void dog_sub_animal ( std :: function < Animal () > func ) { // animal = func(); animal.dosomething // all functions for animals work for dog std :: cout << \"dog_clone is a subtype of animal_clone\" << '\\n' ; } int main () { // Clone: animal_clone <: dog_clone? // what dog_clone can do, animal_clone can do // think of a function that takes dog_clone as input, but animal_clone cannot work animal_sub_dog ( animal_clone ); // Clone: dog_clone <: animal_clone? // what animal_clone can do, dog_clone can do dog_sub_animal ( dog_clone ); // pointer follows covariance // Dog <: Animal // Animal* dog_to_animal = new Dog(); // Dog* animal_to_dog = new Animal(); } #include <iostream> #include <string> #include <functional> class Animal { public : int name = 0 ; void sleep (){} virtual void f ( Animal a ) {} }; class Dog : public Animal { public : int dog_name = 1 ; // change this to virtual void sleep (){} void bark (){} virtual void f ( Dog d ) {} }; void animal_f ( Animal a ) {} void dog_f ( Dog d ) {} void animal_sub_dog ( std :: function < void ( Dog ) > func ) { //Dog dog; //func(dog) (dog -> animal can work) // the only application that is the difference will be the argument std :: cout << \"animal_f is a subtype of dog_f\" << '\\n' ; } void dog_sub_animal ( std :: function < void ( Animal ) > func ) { // Animal animal; // func(animal); // all functions for animals work for dog std :: cout << \"dog_f is a subtype of animal_f\" << '\\n' ; } int main () { // animal_f <: dog_f? animal_sub_dog ( animal_f ); // dog_f <: animal_f? dog_sub_animal ( dog_f ); // another way: // animal_f(animal) works, dog_f(animal) doesn't work // animal_f(dog) works, dog_f(dog) works // ===> dog_f x<: animal_f // dog_f(animal) dosen't work // dog_f(dog) works, animal_f(dog) works // ===> animal_f <: dog_f } #include <iostream> #include <string> #include <functional> class Animal { public : int name = 0 ; void sleep (){} //virtual Animal* clone(Animal* a) {} }; class Dog : public Animal { public : int dog_name = 1 ; // change this to virtual void sleep (){} void bark (){} //Dog* clone(Dog* a) override {} }; Animal dog_to_animal ( Dog a ){} Dog animal_to_dog ( Animal b ){} void one_sub_two ( std :: function < Dog ( Animal ) > func ) { // maybe I'll call bark here // dog = func(); dog.bark(); std :: cout << \"dog_to_animal is a subtype of animal_to_dog\" << '\\n' ; } void two_sub_one ( std :: function < Animal ( Dog ) > func ) { // all functions for animals work for dog std :: cout << \"animal_to_dog is a subtype of dog_to_animal\" << '\\n' ; } int main () { one_sub_two ( dog_to_animal ); two_sub_one ( animal_to_dog ); // animal->dog <: animal->animal <: dog->animal // dog->dog ? animal->animal } #include <iostream> #include <string> #include <functional> class Animal { public : int name = 0 ; void sleep (){} //virtual Animal* clone(Animal* a) {} }; class Dog : public Animal { public : int dog_name = 1 ; // change this to virtual void sleep (){} void bark (){} //Dog* clone(Dog* a) override {} }; Dog dog_to_dog ( Dog a ){} Animal animal_to_animal ( Animal b ){} void one_sub_two ( std :: function < Animal ( Animal ) > func ) { // maybe I'll call bark here // dog = func(); dog.bark(); std :: cout << \"dog_to_dog is a subtype of animal_to_animal\" << '\\n' ; } void two_sub_one ( std :: function < Dog ( Dog ) > func ) { // all functions for animals work for dog std :: cout << \"animal_to_animal is a subtype of dog_to_dog\" << '\\n' ; } int main () { one_sub_two ( dog_to_dog ); two_sub_one ( animal_to_animal ); // animal->dog <: animal->animal <: dog->animal // dog->dog ? animal->animal } #include <iostream> #include <string> #include <functional> class Food { public : void eaten (){} }; class DogFood : public Food { public : void eaten (){} }; class Animal { public : int name = 0 ; void sleep (){} }; class Dog : public Animal { public : int dog_name = 1 ; void sleep (){} void bark (){} }; DogFood animal_dogfood ( Animal a ){} Food dog_food ( Dog b ){} void one_sub_two ( std :: function < Food ( Dog ) > func ) { // maybe I'll call bark here // dog = func(); dog.bark(); std :: cout << \"animal_dogfood is a subtype of dog_food\" << '\\n' ; } void two_sub_one ( std :: function < DogFood ( Animal ) > func ) { // all functions for animals work for dog std :: cout << \"dog_food is a subtype of animal_dogfood\" << '\\n' ; } int main () { one_sub_two ( animal_dogfood ); two_sub_one ( dog_food ); // animal->dog <: animal->animal <: dog->animal // dog->dog ? animal->animal }","title":"Week 4"},{"location":"discussions/week4/#week-4-discussion","text":"Here is the code we went over in discussion. #include <iostream> #include <string> class Animal { public : int name = 0 ; virtual void sleep () { std :: cout << \"sleeping...zzz\" << '\\n' ; } }; class Dog : public Animal { public : // change this to virtual int dogname = - 1 ; virtual void sleep () { std :: cout << \"a dog is sleeping...zzz\" << '\\n' ; } void bark () { std :: cout << \"bark bark\" << '\\n' ; } }; int main () { // will this work? dog_to_animal -> bark (); //__Animal_bark() // non-virtual sleep dog_to_animal -> sleep (); // __Animal_sleep() //Animal* dog_to_animal = new Dog(); //std::cout << dog_to_animal->dogname << '\\n'; // will this work? --subtyping Dog * animal_to_dog = new Animal (); } #include <iostream> #include <string> class Shape { public : virtual double area (){ return - 1 ;} }; class Circle : public Shape { double r ; public : Circle ( double radius ) { r = radius ;} // change this to virtual double area () { return r * r * 3.14159265 ; } }; class Rectangle : public Shape { double a , b ; public : Rectangle ( double _a , double _b ) { a = _a ; b = _b ;} // change this to virtual double area () { return a * b ; } }; void calculate_area_1 ( Shape * s ) { std :: cout << s -> area () << '\\n' ; } // pass by reference void calculate_area_2 ( Shape & s ) { std :: cout << s . area () << '\\n' ; } // pass by value: create a new instance void calculate_area_3 ( Shape s ) { std :: cout << s . area () << '\\n' ; } int main () { Circle c = Circle ( 1.0 ); Rectangle r = Rectangle ( 1.0 , 1.0 ); // pass by pointer calculate_area_1 ( & c ); calculate_area_1 ( & r ); // pass by reference //calculate_area_2(c); //calculate_area_2(r); // pass by value: create a new instance //calculate_area_3(c); //calculate_area_3(r); } #include <iostream> #include <string> #include <functional> class Animal { public : int name = 0 ; void sleep (){} }; class Dog : public Animal { public : int name = 3 ; // change this to virtual void sleep (){} void bark (){} }; Animal animal_clone () { } Dog dog_clone () { } // Q: dog_clone ? animal_clone // why? void animal_sub_dog ( std :: function < Dog () > func ) { // maybe I'll call bark here // dog = func(); dog.bark(); std :: cout << \"animal_clone is a subtype of dog_clone\" << '\\n' ; } void dog_sub_animal ( std :: function < Animal () > func ) { // animal = func(); animal.dosomething // all functions for animals work for dog std :: cout << \"dog_clone is a subtype of animal_clone\" << '\\n' ; } int main () { // Clone: animal_clone <: dog_clone? // what dog_clone can do, animal_clone can do // think of a function that takes dog_clone as input, but animal_clone cannot work animal_sub_dog ( animal_clone ); // Clone: dog_clone <: animal_clone? // what animal_clone can do, dog_clone can do dog_sub_animal ( dog_clone ); // pointer follows covariance // Dog <: Animal // Animal* dog_to_animal = new Dog(); // Dog* animal_to_dog = new Animal(); } #include <iostream> #include <string> #include <functional> class Animal { public : int name = 0 ; void sleep (){} virtual void f ( Animal a ) {} }; class Dog : public Animal { public : int dog_name = 1 ; // change this to virtual void sleep (){} void bark (){} virtual void f ( Dog d ) {} }; void animal_f ( Animal a ) {} void dog_f ( Dog d ) {} void animal_sub_dog ( std :: function < void ( Dog ) > func ) { //Dog dog; //func(dog) (dog -> animal can work) // the only application that is the difference will be the argument std :: cout << \"animal_f is a subtype of dog_f\" << '\\n' ; } void dog_sub_animal ( std :: function < void ( Animal ) > func ) { // Animal animal; // func(animal); // all functions for animals work for dog std :: cout << \"dog_f is a subtype of animal_f\" << '\\n' ; } int main () { // animal_f <: dog_f? animal_sub_dog ( animal_f ); // dog_f <: animal_f? dog_sub_animal ( dog_f ); // another way: // animal_f(animal) works, dog_f(animal) doesn't work // animal_f(dog) works, dog_f(dog) works // ===> dog_f x<: animal_f // dog_f(animal) dosen't work // dog_f(dog) works, animal_f(dog) works // ===> animal_f <: dog_f } #include <iostream> #include <string> #include <functional> class Animal { public : int name = 0 ; void sleep (){} //virtual Animal* clone(Animal* a) {} }; class Dog : public Animal { public : int dog_name = 1 ; // change this to virtual void sleep (){} void bark (){} //Dog* clone(Dog* a) override {} }; Animal dog_to_animal ( Dog a ){} Dog animal_to_dog ( Animal b ){} void one_sub_two ( std :: function < Dog ( Animal ) > func ) { // maybe I'll call bark here // dog = func(); dog.bark(); std :: cout << \"dog_to_animal is a subtype of animal_to_dog\" << '\\n' ; } void two_sub_one ( std :: function < Animal ( Dog ) > func ) { // all functions for animals work for dog std :: cout << \"animal_to_dog is a subtype of dog_to_animal\" << '\\n' ; } int main () { one_sub_two ( dog_to_animal ); two_sub_one ( animal_to_dog ); // animal->dog <: animal->animal <: dog->animal // dog->dog ? animal->animal } #include <iostream> #include <string> #include <functional> class Animal { public : int name = 0 ; void sleep (){} //virtual Animal* clone(Animal* a) {} }; class Dog : public Animal { public : int dog_name = 1 ; // change this to virtual void sleep (){} void bark (){} //Dog* clone(Dog* a) override {} }; Dog dog_to_dog ( Dog a ){} Animal animal_to_animal ( Animal b ){} void one_sub_two ( std :: function < Animal ( Animal ) > func ) { // maybe I'll call bark here // dog = func(); dog.bark(); std :: cout << \"dog_to_dog is a subtype of animal_to_animal\" << '\\n' ; } void two_sub_one ( std :: function < Dog ( Dog ) > func ) { // all functions for animals work for dog std :: cout << \"animal_to_animal is a subtype of dog_to_dog\" << '\\n' ; } int main () { one_sub_two ( dog_to_dog ); two_sub_one ( animal_to_animal ); // animal->dog <: animal->animal <: dog->animal // dog->dog ? animal->animal } #include <iostream> #include <string> #include <functional> class Food { public : void eaten (){} }; class DogFood : public Food { public : void eaten (){} }; class Animal { public : int name = 0 ; void sleep (){} }; class Dog : public Animal { public : int dog_name = 1 ; void sleep (){} void bark (){} }; DogFood animal_dogfood ( Animal a ){} Food dog_food ( Dog b ){} void one_sub_two ( std :: function < Food ( Dog ) > func ) { // maybe I'll call bark here // dog = func(); dog.bark(); std :: cout << \"animal_dogfood is a subtype of dog_food\" << '\\n' ; } void two_sub_one ( std :: function < DogFood ( Animal ) > func ) { // all functions for animals work for dog std :: cout << \"dog_food is a subtype of animal_dogfood\" << '\\n' ; } int main () { one_sub_two ( animal_dogfood ); two_sub_one ( dog_food ); // animal->dog <: animal->animal <: dog->animal // dog->dog ? animal->animal }","title":"Week 4 Discussion"},{"location":"lectures/week1/","text":"Lecture slides and code \u00b6 Introduction: pdf , key JavaScript in a Nutshell: pdf , key Lambda Calculus Fundamentals: pdf Discussion section notes: here Recommended reading \u00b6 If you have not worked with JavaScript before, take some time to familiarize yourself with the basics of the language, as most of the labs in this class will be in JavaScript. We recommend the Mozilla Developer Network's JavaScript Guide , but there are many other tutorials on the Internet. Dave Herman's Effective JavaScript is very good reference that covers a lot of the JavaScript intricacies. You will not need this for the class, but if you end up writing JavaScript code in the outside world, this book is must-read. Additional resources/reading for the curious \u00b6 Block bindings and the difference between var , let , and const . Why a language like JavaScript took over the world? Not that uncommon, see The Rise of \"Worse is Better\" . Closures explained; see, especially the creating closures in a loop section. Private properties in (modern) JavaScript ; we will revisit the idea of private properties (encapsulation) later in the course. Short intro to memory management for JavaScript . ES6 In Depth contains more information on the more recent features introduced to JavaScript. Arrow functions . JavaScript No-No's . Source code used in class \u00b6 Below you'll find the source files we used during lecture. You can run these with Node.js . Scoping \u00b6 Block scoping in modern JS: function hello ( x ) { console . log ( `A: x = ${ x } ` ); // 42 { let x = 45 ; console . log ( `B: x = ${ x } ` ); // 45 } { console . log ( `C: x = ${ x } ` ); // 42 } } hello ( 42 ); Function (but not block) scoping for var s: function hello ( x ) { console . log ( `A: x = ${ x } ` ); // ?? { var x = 45 ; console . log ( `B: x = ${ x } ` ); // ?? } { console . log ( `C: x = ${ x } ` ); // ?? } } hello ( 42 ); Mimicking block scoping with functions: function hello ( x ) { console . log ( `A: x = ${ x } ` ); // ?? ( function () { var x = 45 ; console . log ( `B: x = ${ x } ` ); // ?? })(); ( function () { console . log ( `C: x = ${ x } ` ); // ?? })(); } hello ( 42 ); Now, with arrow functions: function hello ( x ) { console . log ( `A: x = ${ x } ` ); // ?? ( function () { var x = 45 ; console . log ( `B: x = ${ x } ` ); // ?? })(); (() => { console . log ( `C: x = ${ x } ` ); // ?? })(); } hello ( 42 ); Performance \u00b6 Without high-order functions, we'd perform reads and write synchronously: const fs = require ( 'fs' ); const r1 = fs . readFileSync ( './perf-sync.js' , 'utf8' ); // blocks until read is done processFile ( 'perf-sync.js' , r1 ); // blocks until processing (write) is done const r2 = fs . readFileSync ( './perf-async.js' , 'utf8' ); // etc. processFile ( 'perf-async.js' , r2 ); // note that you can declare a function after the point it's used. Hoisting // essentially moves it to the top. function processFile ( fname , str ) { fs . writeFileSync ( `/tmp/ ${ fname } ` , str ); console . log ( `DONE writing /tmp/ ${ fname } ` ); } Passing (callback) functions as arguments allows the runtime system to call our function whenever it's ready. This allows it to perform IO concurrently and more efficiently: const fs = require ( 'fs' ); fs . readFile ( './perf-sync.js' , 'utf8' , cb1 ); // returns immediately, cb1 is queued on the event loop and called later when actual file read is done fs . readFile ( './perf-async.js' , 'utf8' , cb2 ); // returns immediately, \" \" function processFile ( fname , str ) { fs . writeFileSync ( `/tmp/ ${ fname } ` , str ); console . log ( `DONE writing /tmp/ ${ fname } ` ); } function cb1 ( err , str ) { // line cb1.1 processFile ( 'perf-sync.js' , str ); } function cb2 ( err , str ) { //line cb2.1 processFile ( 'perf-async.js' , str ); } Can cb2 execute before cb1 ? A : yes , B : no Once we can return functions we can also express our code more compactly too: const fs = require ( 'fs' ); fs . readFile ( './perf-sync.js' , 'utf8' , processFile ( 'perf-sync.js' )); fs . readFile ( './perf-async.js' , 'utf8' , processFile ( 'perf-async.js' )); function processFile ( fname ) { return ( err , str ) => { fs . writeFileSync ( `/tmp/ ${ fname } ` , str ); console . log ( `DONE writing /tmp/ ${ fname } ` ); }; } And, slightly cleaner: const fs = require ( 'fs' ); readAndProcessFile ( 'perf-sync.js' ); readAndProcessFile ( 'perf-async.js' ); function readAndProcessFile ( name ) { return fs . readFile ( `./ ${ name } ` , 'utf8' , processFile ( name )); } function processFile ( fname ) { return ( err , str ) => { fs . writeFileSync ( `/tmp/ ${ fname } ` , str ); console . log ( `DONE writing /tmp/ ${ fname } ` ); }; } Expressiveness \u00b6 High-order functions enables expressiveness: const list = [ 1 , 2 , 3 , 4 ]; console . log ( filter ( list , function ( el ) { return el > 2 ; })); // ?? console . log ( map ( list , el => { return el + 42 ; })); // ?? function filter ( list , pred ) { const dup = []; for ( let i = 0 ; i < list . length ; i ++ ) { if ( pred ( list [ i ])) { dup . push ( list [ i ]); } } return dup ; } function map ( list , f ) { const dup = []; for ( let i = list . length - 1 ; i >= 0 ; i -- ) { dup . unshift ( f ( list [ i ])); } return dup ; } It also can enable more efficient code: const list = [ 1 , 2 , 3 , 4 ]; const add42 = ( el ) => { return el + 42 ; }; function mul1337 ( el ) { return el * 1337 ; } console . log ( map ( map ( list , add42 ), mul1337 )); console . log ( map ( list , compose ( mul1337 , add42 ))); function compose ( f , g ) { return ( x ) => { return f ( g ( x )); } } function map ( list , f ) { const dup = []; for ( let i = list . length - 1 ; i >= 0 ; i -- ) { dup . unshift ( f ( list [ i ])); } return dup ; } Abstraction \u00b6 We can also use functions to implement module systems. Consider a simple module in Node.js: const secret = \"cse130 is fun!\" ; // scoped to this function, hidden to outside world exports . myVar = 42 ; exports . myFunc = function ( x ) { if ( x === secret ) { console . log ( 'yes!' ); } else { console . log ( 'guess again!' ); } }; This module can be loaded with require , which is (very) roughly implemented as follows: // using node's requie: { const mod = require ( './module-node.js' ); console . log ( mod . myVar ); // ?? mod . myFunc ( \"what?\" ); // ?? mod . myFunc ( \"cse130 is fun!\" ); // ?? } // using our fake require: { const mod = requireMyModule (); console . log ( mod . myVar ); // ?? mod . myFunc ( \"what?\" ); // ?? mod . myFunc ( \"cse130 is fun!\" ); // ?? } function myModule ( exports ) { // same code as module-node.js: const secret = \"cse130 is fun!\" ; // scoped to this function, hidden to outside world exports . myVar = 42 ; exports . myFunc = function ( x ) { if ( x === secret ) { console . log ( 'yes!' ); } else { console . log ( 'guess again!' ); } }; } function requireMyModule () { // create new object that will be populated by the module const exports = {}; myModule ( exports ); return exports ; } Objects \u00b6 We'll be looking at objects later in the class. Objects can be expressed ad-hoc, using object literal notation: const obj = { \"x-w00t\" : 10 , x : 1337 , f : function ( y ) { this . x ++ ; return this . x + y ; } }; console . log ( obj . x ); // ?? console . log ( obj . f ( 3 )); // ?? console . log ( obj [ \"x\" ]); // ?? console . log ( obj [ \"x-w00t\" ]) // ?? But we can (again) use functions to construct objects: function Car ( make , model ) { this . make = make ; this . model = model ; this . toString = function () { return ` ${ this . make } @ ${ this . model } ` ; }; } Car . mySweetProp = 42 ; const f = new Car ( \"Ford\" , \"Focus\" ); console . log ( f . toString ()); const t = new Car ( \"Toyota\" , \"Corola\" ); console . log ( t . toString ()); // Car.prototype is shared by all objects created by calling new Car(...) // That's right you can treat functions like objects! console . log ( f . __proto__ === Car . prototype ); // ?? // Let's define property common to all cars: Car . prototype . color = \"black\" ; console . log ( f . color ); // ?? // getProperty \"color\" of f // if it has it, return it // else getProperty \"color\" of f.__proto__ console . log ( t . color ); // ?? // Can override the default color that is defined on the prototype: t . color = \"red\" ; console . log ( t . color ); // ?? console . log ( f . color ); // ?? // We can define a method on the prototype: Car . prototype . toColorString = function () { return ` ${ this . make } , ${ this . model } , ${ this . color } ` ; }; console . log ( f . toColorString ()); // ?? console . log ( t . toColorString ()); // ?? More recently, however, JavaScript adopted classes. You can think of them as being syntactic sugar for the above: class Car { constructor ( make , model ) { this . make = make ; this . model = model ; } toString () { return ` ${ this . make } @ ${ this . model } ` ; } static get mySweetProp () { return 42 ; } } const f = new Car ( \"Ford\" , \"Focus\" ); console . log ( f . toString ()); const t = new Car ( \"Toyota\" , \"Corola\" ); console . log ( t . toString ()); // Car.prototype is shared by all objects created by calling new Car(...) // That's right you can treat functions like objects! console . log ( f . __proto__ === Car . prototype ); // ?? // We can define property common to all cars as before: Car . prototype . color = \"black\" ; console . log ( f . color ); // ?? // getProperty \"color\" of f // if it has it, return it // else getProperty \"color\" of f.__proto__ console . log ( t . color ); // ?? // Can override the default color that is defined on the prototype: t . color = \"red\" ; console . log ( t . color ); // ?? console . log ( f . color ); // ?? // We can define a method on the prototype as before: Car . prototype . toColorString = function () { return ` ${ this . make } , ${ this . model } , ${ this . color } ` ; }; console . log ( f . toColorString ()); // ?? console . log ( t . toColorString ()); // ??","title":"Week 1"},{"location":"lectures/week1/#lecture-slides-and-code","text":"Introduction: pdf , key JavaScript in a Nutshell: pdf , key Lambda Calculus Fundamentals: pdf Discussion section notes: here","title":"Lecture slides and code"},{"location":"lectures/week1/#recommended-reading","text":"If you have not worked with JavaScript before, take some time to familiarize yourself with the basics of the language, as most of the labs in this class will be in JavaScript. We recommend the Mozilla Developer Network's JavaScript Guide , but there are many other tutorials on the Internet. Dave Herman's Effective JavaScript is very good reference that covers a lot of the JavaScript intricacies. You will not need this for the class, but if you end up writing JavaScript code in the outside world, this book is must-read.","title":"Recommended reading"},{"location":"lectures/week1/#additional-resourcesreading-for-the-curious","text":"Block bindings and the difference between var , let , and const . Why a language like JavaScript took over the world? Not that uncommon, see The Rise of \"Worse is Better\" . Closures explained; see, especially the creating closures in a loop section. Private properties in (modern) JavaScript ; we will revisit the idea of private properties (encapsulation) later in the course. Short intro to memory management for JavaScript . ES6 In Depth contains more information on the more recent features introduced to JavaScript. Arrow functions . JavaScript No-No's .","title":"Additional resources/reading for the curious"},{"location":"lectures/week1/#source-code-used-in-class","text":"Below you'll find the source files we used during lecture. You can run these with Node.js .","title":"Source code used in class"},{"location":"lectures/week1/#scoping","text":"Block scoping in modern JS: function hello ( x ) { console . log ( `A: x = ${ x } ` ); // 42 { let x = 45 ; console . log ( `B: x = ${ x } ` ); // 45 } { console . log ( `C: x = ${ x } ` ); // 42 } } hello ( 42 ); Function (but not block) scoping for var s: function hello ( x ) { console . log ( `A: x = ${ x } ` ); // ?? { var x = 45 ; console . log ( `B: x = ${ x } ` ); // ?? } { console . log ( `C: x = ${ x } ` ); // ?? } } hello ( 42 ); Mimicking block scoping with functions: function hello ( x ) { console . log ( `A: x = ${ x } ` ); // ?? ( function () { var x = 45 ; console . log ( `B: x = ${ x } ` ); // ?? })(); ( function () { console . log ( `C: x = ${ x } ` ); // ?? })(); } hello ( 42 ); Now, with arrow functions: function hello ( x ) { console . log ( `A: x = ${ x } ` ); // ?? ( function () { var x = 45 ; console . log ( `B: x = ${ x } ` ); // ?? })(); (() => { console . log ( `C: x = ${ x } ` ); // ?? })(); } hello ( 42 );","title":"Scoping"},{"location":"lectures/week1/#performance","text":"Without high-order functions, we'd perform reads and write synchronously: const fs = require ( 'fs' ); const r1 = fs . readFileSync ( './perf-sync.js' , 'utf8' ); // blocks until read is done processFile ( 'perf-sync.js' , r1 ); // blocks until processing (write) is done const r2 = fs . readFileSync ( './perf-async.js' , 'utf8' ); // etc. processFile ( 'perf-async.js' , r2 ); // note that you can declare a function after the point it's used. Hoisting // essentially moves it to the top. function processFile ( fname , str ) { fs . writeFileSync ( `/tmp/ ${ fname } ` , str ); console . log ( `DONE writing /tmp/ ${ fname } ` ); } Passing (callback) functions as arguments allows the runtime system to call our function whenever it's ready. This allows it to perform IO concurrently and more efficiently: const fs = require ( 'fs' ); fs . readFile ( './perf-sync.js' , 'utf8' , cb1 ); // returns immediately, cb1 is queued on the event loop and called later when actual file read is done fs . readFile ( './perf-async.js' , 'utf8' , cb2 ); // returns immediately, \" \" function processFile ( fname , str ) { fs . writeFileSync ( `/tmp/ ${ fname } ` , str ); console . log ( `DONE writing /tmp/ ${ fname } ` ); } function cb1 ( err , str ) { // line cb1.1 processFile ( 'perf-sync.js' , str ); } function cb2 ( err , str ) { //line cb2.1 processFile ( 'perf-async.js' , str ); } Can cb2 execute before cb1 ? A : yes , B : no Once we can return functions we can also express our code more compactly too: const fs = require ( 'fs' ); fs . readFile ( './perf-sync.js' , 'utf8' , processFile ( 'perf-sync.js' )); fs . readFile ( './perf-async.js' , 'utf8' , processFile ( 'perf-async.js' )); function processFile ( fname ) { return ( err , str ) => { fs . writeFileSync ( `/tmp/ ${ fname } ` , str ); console . log ( `DONE writing /tmp/ ${ fname } ` ); }; } And, slightly cleaner: const fs = require ( 'fs' ); readAndProcessFile ( 'perf-sync.js' ); readAndProcessFile ( 'perf-async.js' ); function readAndProcessFile ( name ) { return fs . readFile ( `./ ${ name } ` , 'utf8' , processFile ( name )); } function processFile ( fname ) { return ( err , str ) => { fs . writeFileSync ( `/tmp/ ${ fname } ` , str ); console . log ( `DONE writing /tmp/ ${ fname } ` ); }; }","title":"Performance"},{"location":"lectures/week1/#expressiveness","text":"High-order functions enables expressiveness: const list = [ 1 , 2 , 3 , 4 ]; console . log ( filter ( list , function ( el ) { return el > 2 ; })); // ?? console . log ( map ( list , el => { return el + 42 ; })); // ?? function filter ( list , pred ) { const dup = []; for ( let i = 0 ; i < list . length ; i ++ ) { if ( pred ( list [ i ])) { dup . push ( list [ i ]); } } return dup ; } function map ( list , f ) { const dup = []; for ( let i = list . length - 1 ; i >= 0 ; i -- ) { dup . unshift ( f ( list [ i ])); } return dup ; } It also can enable more efficient code: const list = [ 1 , 2 , 3 , 4 ]; const add42 = ( el ) => { return el + 42 ; }; function mul1337 ( el ) { return el * 1337 ; } console . log ( map ( map ( list , add42 ), mul1337 )); console . log ( map ( list , compose ( mul1337 , add42 ))); function compose ( f , g ) { return ( x ) => { return f ( g ( x )); } } function map ( list , f ) { const dup = []; for ( let i = list . length - 1 ; i >= 0 ; i -- ) { dup . unshift ( f ( list [ i ])); } return dup ; }","title":"Expressiveness"},{"location":"lectures/week1/#abstraction","text":"We can also use functions to implement module systems. Consider a simple module in Node.js: const secret = \"cse130 is fun!\" ; // scoped to this function, hidden to outside world exports . myVar = 42 ; exports . myFunc = function ( x ) { if ( x === secret ) { console . log ( 'yes!' ); } else { console . log ( 'guess again!' ); } }; This module can be loaded with require , which is (very) roughly implemented as follows: // using node's requie: { const mod = require ( './module-node.js' ); console . log ( mod . myVar ); // ?? mod . myFunc ( \"what?\" ); // ?? mod . myFunc ( \"cse130 is fun!\" ); // ?? } // using our fake require: { const mod = requireMyModule (); console . log ( mod . myVar ); // ?? mod . myFunc ( \"what?\" ); // ?? mod . myFunc ( \"cse130 is fun!\" ); // ?? } function myModule ( exports ) { // same code as module-node.js: const secret = \"cse130 is fun!\" ; // scoped to this function, hidden to outside world exports . myVar = 42 ; exports . myFunc = function ( x ) { if ( x === secret ) { console . log ( 'yes!' ); } else { console . log ( 'guess again!' ); } }; } function requireMyModule () { // create new object that will be populated by the module const exports = {}; myModule ( exports ); return exports ; }","title":"Abstraction"},{"location":"lectures/week1/#objects","text":"We'll be looking at objects later in the class. Objects can be expressed ad-hoc, using object literal notation: const obj = { \"x-w00t\" : 10 , x : 1337 , f : function ( y ) { this . x ++ ; return this . x + y ; } }; console . log ( obj . x ); // ?? console . log ( obj . f ( 3 )); // ?? console . log ( obj [ \"x\" ]); // ?? console . log ( obj [ \"x-w00t\" ]) // ?? But we can (again) use functions to construct objects: function Car ( make , model ) { this . make = make ; this . model = model ; this . toString = function () { return ` ${ this . make } @ ${ this . model } ` ; }; } Car . mySweetProp = 42 ; const f = new Car ( \"Ford\" , \"Focus\" ); console . log ( f . toString ()); const t = new Car ( \"Toyota\" , \"Corola\" ); console . log ( t . toString ()); // Car.prototype is shared by all objects created by calling new Car(...) // That's right you can treat functions like objects! console . log ( f . __proto__ === Car . prototype ); // ?? // Let's define property common to all cars: Car . prototype . color = \"black\" ; console . log ( f . color ); // ?? // getProperty \"color\" of f // if it has it, return it // else getProperty \"color\" of f.__proto__ console . log ( t . color ); // ?? // Can override the default color that is defined on the prototype: t . color = \"red\" ; console . log ( t . color ); // ?? console . log ( f . color ); // ?? // We can define a method on the prototype: Car . prototype . toColorString = function () { return ` ${ this . make } , ${ this . model } , ${ this . color } ` ; }; console . log ( f . toColorString ()); // ?? console . log ( t . toColorString ()); // ?? More recently, however, JavaScript adopted classes. You can think of them as being syntactic sugar for the above: class Car { constructor ( make , model ) { this . make = make ; this . model = model ; } toString () { return ` ${ this . make } @ ${ this . model } ` ; } static get mySweetProp () { return 42 ; } } const f = new Car ( \"Ford\" , \"Focus\" ); console . log ( f . toString ()); const t = new Car ( \"Toyota\" , \"Corola\" ); console . log ( t . toString ()); // Car.prototype is shared by all objects created by calling new Car(...) // That's right you can treat functions like objects! console . log ( f . __proto__ === Car . prototype ); // ?? // We can define property common to all cars as before: Car . prototype . color = \"black\" ; console . log ( f . color ); // ?? // getProperty \"color\" of f // if it has it, return it // else getProperty \"color\" of f.__proto__ console . log ( t . color ); // ?? // Can override the default color that is defined on the prototype: t . color = \"red\" ; console . log ( t . color ); // ?? console . log ( f . color ); // ?? // We can define a method on the prototype as before: Car . prototype . toColorString = function () { return ` ${ this . make } , ${ this . model } , ${ this . color } ` ; }; console . log ( f . toColorString ()); // ?? console . log ( t . toColorString ()); // ??","title":"Objects"},{"location":"lectures/week10/","text":"Lecture slides \u00b6 (Last week) intro to constant-time: pdf , key , Constant-time programming in C: pdf , key , Constant-time programming in FaCT: pdf , key , Recommended reading \u00b6 FaCT: A Flexible, Constant-Time Programming Language by Cauligi et al. FaCT Language Reference Crypto coding rules is an excellent source for transforming C code to constant-time C code. Constant-Time Toolkit by Thomas Pornin On Subnormal Floating Point and Abnormal Timing by Andrysco, et al. Cache-timing attacks on AES by Daniel J. Bernstein (Last week) Why Constant-Time Crypto by Thomas Pornin Code snippets \u00b6 FaCT example \u00b6 /* FaCT tutorial file for CSE 130 */ /* Basic stuff */ export // functions are not exposed to C without `export` keyword public int32 simple_fn() { // return value must be `public` or `secret` return 5; } export public int32 demo_fn( public int32 x, // arguments require a label secret mut uint32 y) { // y can be used as an output parameter since it is `mut` public int32 z = x + 5; // variables also need a label // the following line will cause an error, since z is not `mut` // z += 2; public mut int32 t = z; // this is ok, since t is mutable t += 22; secret mut uint32 w = 16; // error: cannot assign `secret` value to `public` variable // w + x is secret because w is secret // t = w + (uint32)x; // ok: y is secret so it can accept secret expressions y = w + (uint32)x; // this is an error: the return value is public but w is secret // return w; // ok: z is public return z; } export secret uint32 call_demo_fn( public int32 x) { secret mut uint32 output = 0; // has to be `mut` since we're passing it to be updated by `demo_fn` demo_fn(x, ref output); // `ref` keyword is necessary for mutable arguments return output; } export void fill_conditionally( public uint32[4] pattern, // fixed length buffer secret mut uint8[] buf, // buffer length won't be known until run time secret bool b) { // loop iterator must be declared in the for loop header for (uint32 i = 0; i < len buf; i += 1) { // runtime length of buf via `len` keyword // b is secret, so conditional will get transformed // into constant time code during compilation if (b) { // ok to update buf since it is mutable buf[i] = (uint8)pattern[i % 4]; // cast to uint8 so the types match } } } // no export because this is a helper function void twiddle_bytes( secret mut uint8[4] buf) { secret uint8 tmp = buf[0]; buf[0] = buf[2]; buf[2] = tmp; // can't reuse tmp because it was not declared `mut` // (although we could simply change it to be `mut`) secret uint8 tmp2 = buf[1]; buf[1] = buf[3]; buf[3] = tmp2; } void poorly_constructed_hash_fn( secret mut uint8[20] out, secret uint8[] in) { secret mut uint8[20] local = arrzeros(20); // local mutable array, initialized to all zeros for (uint32 i = 0; i < len in; i += 1) { local[i % len local] += in[i]; } for (uint32 i = 0; i < 20; i += 4) { // incrementing by 4s // create a \"view\" of `local` so that it matches with the signature of `twiddle_bytes` twiddle_bytes(ref arrview(local, i, 4)); // view of `local`, starting at index `i`, with a length of 4 } for (uint32 i = 0; i < 20; i += 1) { out[i] = local[i]; } } /* More \"real\" functions */ public int32 conditional_assign( secret mut uint8[] x, secret uint8[] y, secret bool assign) { // public branch if (len x != len y) { return -1; } // secret branch if (assign) { for (uint32 i = 0; i < len x; i += 1) { x[i] = y[i]; } } return 0; } // assuming lengths are public and are equal secret int32 safe_memcmp(secret uint8[] x, secret uint8[] y) { for (uint32 i = 0; i < len x; i += 1) { if (x[i] != y[i]) { return (int32)(x[i] - y[i]); } } return 0; } Compiler-introduced branches \u00b6 #include <stdint.h> #include <stdbool.h> #include <stdlib.h> void mpi_safe_cond_assign ( uint8_t * X , const uint8_t * Y , unsigned char assign ) { size_t i = 0 ; /* make sure assign is 0 or 1 */ assign = ( assign != 0 ); X [ i ] = X [ i ] * ( 1 - assign ) + Y [ i ] * assign ; } Compiled with clang 3.9.1 with -O2 , introduces a branch: mpi_safe_cond_assign ( unsigned char *, unsigned char const *, unsigned char ) : test dl , dl set ne al je . LBB 0 _ 2 mov dl , byte ptr [ rsi ] .LBB0_2: or al , -2 in c al and al , byte ptr [ rdi ] add al , dl mov byte ptr [ rdi ], al ret Play with this code on godbolt","title":"Home"},{"location":"lectures/week10/#lecture-slides","text":"(Last week) intro to constant-time: pdf , key , Constant-time programming in C: pdf , key , Constant-time programming in FaCT: pdf , key ,","title":"Lecture slides"},{"location":"lectures/week10/#recommended-reading","text":"FaCT: A Flexible, Constant-Time Programming Language by Cauligi et al. FaCT Language Reference Crypto coding rules is an excellent source for transforming C code to constant-time C code. Constant-Time Toolkit by Thomas Pornin On Subnormal Floating Point and Abnormal Timing by Andrysco, et al. Cache-timing attacks on AES by Daniel J. Bernstein (Last week) Why Constant-Time Crypto by Thomas Pornin","title":"Recommended reading"},{"location":"lectures/week10/#code-snippets","text":"","title":"Code snippets"},{"location":"lectures/week10/#fact-example","text":"/* FaCT tutorial file for CSE 130 */ /* Basic stuff */ export // functions are not exposed to C without `export` keyword public int32 simple_fn() { // return value must be `public` or `secret` return 5; } export public int32 demo_fn( public int32 x, // arguments require a label secret mut uint32 y) { // y can be used as an output parameter since it is `mut` public int32 z = x + 5; // variables also need a label // the following line will cause an error, since z is not `mut` // z += 2; public mut int32 t = z; // this is ok, since t is mutable t += 22; secret mut uint32 w = 16; // error: cannot assign `secret` value to `public` variable // w + x is secret because w is secret // t = w + (uint32)x; // ok: y is secret so it can accept secret expressions y = w + (uint32)x; // this is an error: the return value is public but w is secret // return w; // ok: z is public return z; } export secret uint32 call_demo_fn( public int32 x) { secret mut uint32 output = 0; // has to be `mut` since we're passing it to be updated by `demo_fn` demo_fn(x, ref output); // `ref` keyword is necessary for mutable arguments return output; } export void fill_conditionally( public uint32[4] pattern, // fixed length buffer secret mut uint8[] buf, // buffer length won't be known until run time secret bool b) { // loop iterator must be declared in the for loop header for (uint32 i = 0; i < len buf; i += 1) { // runtime length of buf via `len` keyword // b is secret, so conditional will get transformed // into constant time code during compilation if (b) { // ok to update buf since it is mutable buf[i] = (uint8)pattern[i % 4]; // cast to uint8 so the types match } } } // no export because this is a helper function void twiddle_bytes( secret mut uint8[4] buf) { secret uint8 tmp = buf[0]; buf[0] = buf[2]; buf[2] = tmp; // can't reuse tmp because it was not declared `mut` // (although we could simply change it to be `mut`) secret uint8 tmp2 = buf[1]; buf[1] = buf[3]; buf[3] = tmp2; } void poorly_constructed_hash_fn( secret mut uint8[20] out, secret uint8[] in) { secret mut uint8[20] local = arrzeros(20); // local mutable array, initialized to all zeros for (uint32 i = 0; i < len in; i += 1) { local[i % len local] += in[i]; } for (uint32 i = 0; i < 20; i += 4) { // incrementing by 4s // create a \"view\" of `local` so that it matches with the signature of `twiddle_bytes` twiddle_bytes(ref arrview(local, i, 4)); // view of `local`, starting at index `i`, with a length of 4 } for (uint32 i = 0; i < 20; i += 1) { out[i] = local[i]; } } /* More \"real\" functions */ public int32 conditional_assign( secret mut uint8[] x, secret uint8[] y, secret bool assign) { // public branch if (len x != len y) { return -1; } // secret branch if (assign) { for (uint32 i = 0; i < len x; i += 1) { x[i] = y[i]; } } return 0; } // assuming lengths are public and are equal secret int32 safe_memcmp(secret uint8[] x, secret uint8[] y) { for (uint32 i = 0; i < len x; i += 1) { if (x[i] != y[i]) { return (int32)(x[i] - y[i]); } } return 0; }","title":"FaCT example"},{"location":"lectures/week10/#compiler-introduced-branches","text":"#include <stdint.h> #include <stdbool.h> #include <stdlib.h> void mpi_safe_cond_assign ( uint8_t * X , const uint8_t * Y , unsigned char assign ) { size_t i = 0 ; /* make sure assign is 0 or 1 */ assign = ( assign != 0 ); X [ i ] = X [ i ] * ( 1 - assign ) + Y [ i ] * assign ; } Compiled with clang 3.9.1 with -O2 , introduces a branch: mpi_safe_cond_assign ( unsigned char *, unsigned char const *, unsigned char ) : test dl , dl set ne al je . LBB 0 _ 2 mov dl , byte ptr [ rsi ] .LBB0_2: or al , -2 in c al and al , byte ptr [ rdi ] add al , dl mov byte ptr [ rdi ], al ret Play with this code on godbolt","title":"Compiler-introduced branches"},{"location":"lectures/week1b/","text":"Lecture slides \u00b6 Foundations and lambda calculus: pdf , key , Recommended reading \u00b6 Textbook: section 4.1.2 and section 4.2 Informal notes on the Y combinator Introduction to Lambda Calculus by Barendregt and Barendsen Ranjit Jhala's lambda calculus slides and the ELSA project.","title":"Week 1b"},{"location":"lectures/week1b/#lecture-slides","text":"Foundations and lambda calculus: pdf , key ,","title":"Lecture slides"},{"location":"lectures/week1b/#recommended-reading","text":"Textbook: section 4.1.2 and section 4.2 Informal notes on the Y combinator Introduction to Lambda Calculus by Barendregt and Barendsen Ranjit Jhala's lambda calculus slides and the ELSA project.","title":"Recommended reading"},{"location":"lectures/week2a/","text":"Lecture slides \u00b6 Scope: pdf , key , Haskell: pdf , key , Recommended reading \u00b6 Textbook: Chapter 7 on Scope, Chapter 5 on Haskell. Philip Guo's JavaScript tutor External sources \u00b6 If you have not worked with Haskell before, take some time to familiarize yourself with the basics of the language. The chapter above is a good start. But there are many other sources to take advantage of, including: Brent Yorgey's Haskell Basics lectures. Learn You a Haskell for Great Good! is also a good book to read through. A history of Haskell: Being lazy with class is a fantastic read, and there is a similarly engaging talk . A history of Haskell: Being lazy with class is a fantastic read. A Gentle Introduction to Haskell 98 The Haskell 2010 Language Source code used in class \u00b6 Below you'll find the source we used during lecture. You can run these with GHCi (e.g., from Haskell Platform ). module Intro where import Prelude hiding ( Either ( .. )) -- # Definitions and bindings -- * Haskell uses the = sign to declare symbol *bindings*: x = 2 -- * They are called variables, but they are not mutable boxes -- * They are like JS's const (but on steroids) -- x = 3 -- is this allowed? -- * 'let' introduces local bindings (new scope) example0 = let x = 44 -- this \"shadows\" above x z = x - 2 in z * 2 -- what is x here? A: 2, B: 44 -- * Variables are order-independent a = if y then 'a' else 'b' -- we use the y defined below: y = True -- # Essence of programming in Haskell -- * Everything is an expression -- * Expressions evaluate to values -- - What's the diff between expressions and values? -- * Programming in Haskell: substituting equals by equals -- - Lambda calculus for the win! {- example0 = let x = 44 z = x - 2 in z * 2 --> = let z = 44 - 2 in z * 2 --> = (44 - 2) * 2 --> = 42 * 2 --> = 84 -} -- # Every expression has a type -- * E.g., intVal is a word-sized integer intVal :: Int intVal = 31 * ( 42 + 56 ) -- * E.g., ii is an Arbitrarily large integer ii :: Integer ii = 31 * ( 42 + 56000000 * 1000 ) -- * E.g., dbl is a double precision floating point dbl = 3 * ( 4.2 + 5.6 ) -- * E.g., chr is a unicode character chr = 'a' :: Char -- * E.g., str is a String = [Char] str = \"w00t\" :: String listOfInt :: [ Int ] listOfInt = [ 1 , 2 , 3 ] -- * E.g., truth is a Boolean truth = True :: Bool -- ## Some remarks about types {- * We didn't need to add type annotations: Haskell infers types - Inspect types in GHCi with :t - You should generally specify types anyway. Why? * Is this the same thing as not having to specify types in JS? - A: yes, B: no -} -- * Haskell doesn't do any implicit conversions -- - What's the type of ii_x_dbl below: -- ii_x_dbl = ii + dbl :: ??? -- - A: Double, B: Int, C: Type error -- * Arithmetic operators + and * are overloaded (as are some other) ii_add = ii + 33 -- :: ? dbl_add = dbl + 33.0 -- :: ? -- * We'll talk about overloading more in the upcoming classes -- # Functions -- * Functions have \"arrow types\" pos :: Integer -> Bool -- * Function arguments separated by space not (,)'s pos x = x > 0 -- * As in JS, you can just use lambdas instead: gt :: Int -> Int -> Bool gt = \\ x y -> x > y -- \\xy.(x > y) -- * Function application is like in lambda calculus: is33pos = pos 33 -- True -- * How you should NOT think about functions (or expressions): -- - What does this function do? -- * How you should think: what does this mean? Think math! -- * In Haskell, f :: A -> B means: -- - For every element x \u2208 A, -- f(x) = y for some some element y \u2208 B -- or f(x) diverges -- ## Multi-argument functions -- * Functions can take multiple arguments arith :: Int -> Int -> Int -> Int arith x y z = x * ( y + z ) -- * Function appication happens one argument at a time (\"currying\") add x y = x + y five = add 3 2 -- is the same as: (add 3) 2 add3 = add 3 -- :: ??? -- - What's another way to write add3? -- * All Haskell functions take one argument -- - Multi-argument functions just return funtions -- - E.g., the type of add with ()'s added: add :: Integer -> ( Integer -> Integer ) -- - We usually ommit ()'s since -> is right-associative add4Things :: Float -> ( Float -> ( Float -> ( Float -> Float ))) add4Things x y z w = x + y + z + w + ( 1.0 :: Float ) -- # Tuples and lists -- * Haskell has basic support for tuples -- - Constructors: (), (,), (,,), ... -- - E.g., tuples unit = () :: () -- kind of like void tuple2 = ( 3 , 'w' ) :: ( Int , Char ) tuple3 = ( 3 , 'w' , 3.3 ) :: ( Int , Char , Double ) funAdd :: ( Int , Int ) -> Int funAdd ( x , y ) = x + y funAdd35 = funAdd ( 3 , 5 ) -- * Haskell has basic support for homogeneous lists -- - Constructors: (:) | [] myIntList'' = [ 1 , 2 , 3 ] :: [ Int ] -- same as consing things: myIntList''' = 1 : 2 : 3 :[] -- (:) :: Int -> [Int] -> [Int] -- (:) 3 [] == 3:[] == [3] -- * Cons (:) is used to add elements to the list; ++ can be used to -- concatenate lists: concatenatedList = [ 1 , 2 , 3 ] ++ [ 4 , 5 , 6 ] -- * Empty lists myEmptyBoolList :: [ Bool ] myEmptyBoolList = [] myEmptyCharList :: [ Char ] myEmptyCharList = [] -- * Haskell does not have support for heterogenous lists -- - E.g., myHeteroList = [1, 'w'] :: ??? -- # Abstract data types -- * The 'data' keyword declares user-defined data types data PairT = PairC Int Int deriving Show -- means you can print types -- - New type: PairT -- - Value/data constructor: PairC -- - A value of this type encapsulates two Int's myPair :: PairT myPair = PairC 3 4 -- * One type can have multiple constructors data Point = Cartesian Double Double | Polar Double Double deriving Show point1 , point2 :: Point point1 = Cartesian 3.3 2.2 point2 = Polar 0.1 3.14 data Color = Red | Green | Blue | Indigo | Violet deriving Show myRed = Red :: Color -- ## Using ADTs -- * Constructors are like functions, can partially apply: myPair' :: Int -> PairT myPair' = PairC 3 -- * Case expressions can be used to \"de-construct\" values with patterns getX :: PairT -> Int getX pair = case pair of PairC x y -> x -- E.g., convert point to cartesian: toCartesian :: Point -> Point toCartesian point = case point of Polar r theta -> Cartesian ( r * cos theta ) ( r * sin theta ) -- Cartesian x y -> Cartesian x y -- or, less verbose: pt @ ( Cartesian _ _ ) -> pt -- We can define a tiny language with addition and multiplication: data Expr = AddExpr Expr Expr | MulExpr Expr Expr | ConstExpr Int deriving Show eval :: Expr -> Int eval ( ConstExpr n ) = n eval ( AddExpr e1 e2 ) = eval e1 + eval e2 eval ( MulExpr e1 e2 ) = eval e1 * eval e2 -- ## Pattern matching beyond case -- * Can use patterns instead of variables beyond case -- - E.g., when defining functions: toCartesian' :: Point -> Point toCartesian' ( Polar r theta ) = Cartesian ( r * cos theta ) ( r * sin theta ) toCartesian' x = x -- - E.g., in a let block getY pair = let ( PairC _ y ) = pair in y -- * The order of pattern matching matters -- - E.g., What happens if we swap order? factorial' 0 = 1 factorial' n = n * ( factorial' ( n - 1 )) -- * You can alternatively guard definitions: factorial'' n | isLT0 n = 1 factorial'' n | otherwise = n * ( factorial'' ( n - 1 )) -- * Guards are just predicates isLT0 :: Int -> Bool isLT0 = ( <= 0 ) -- ## Recursive datatypes -- * Datatypes can be defined recursively -- - E.g., int list: data IntList = INil | ICons Int IntList deriving Show -- ^^^^^^^ myEmptyIntList = INil :: IntList myIntList = ICons 1 ( ICons 2 ( ICons 3 myEmptyIntList )) :: IntList sumOfIntList :: IntList -> Int sumOfIntList INil = 0 sumOfIntList ( ICons x xs ) = x + ( sumOfIntList xs ) {- Solution: sumOfIntList INil = error \"Empty list\" sumOfIntList (ICons x INil) = x sumOfIntList (ICons x xs) = x + sumOfIntList xs -} six :: Bool six = sumOfIntList myIntList == 6 -- ## Polymorphic datatypes -- * I want a list of Char's or String's or Point's -- - Define separate datatype for each: crazy! We want re-usability! data CharList = CNil | CCons Char CharList deriving Show -- * May want to have functions that work on any kind of lists -- - Solution: parametrized types -- * Types can have parameters (kind of like functions) data List a = Nil | Cons a ( List a ) deriving Show -- ^ ^^^^^^ -- - Here, List itself takes an argument: type variable a. -- - Can use type variable a in constructor -- - Cons and Nil work on any types: myIntList' :: List Int myIntList' = Cons 1 ( Cons 2 ( Cons 3 Nil )) myCharList' :: List Char myCharList' = Cons 'a' ( Cons 'b' ( Cons 'c' Nil )) llength :: List a -> Int llength = undefined {- Solution: llength Nil = 0 llength (Cons x xs) = 1 + llength xs -} myList'len :: Bool myList'len = 3 == llength myIntList' && 3 == llength myCharList' -- ## Polymorphic datatypes with multiple parameters -- * Can have multiple type variables data Either a b = Left a | Right b deriving Show safeDiv :: Int -> Int -> Either String Int safeDiv _ 0 = myErr safeDiv x y = Right $ x ` div ` y -- * What is the type of: --myErr :: ??? myErr = Left \"You can't divide by zero, silly.\" -- # Lazyness -- * Definitions of symbols evauated ony when needed -- - E.g., safe division: safeDiv' x y = let q = div x y -- safe as q never evaluated if y == 0 in if y == 0 then 0 else q -- * Infinite data structures posInts = [ 1 .. ] :: [ Int ] -- * Custom control \"primitives\" -- - E.g., if: if' b x y = case b of True -> x _ -> y -- - E.g., loop forever: forever x = forever x -- - What doe the following mean? exampleF = if' True 3 ( forever 4 ) -- ## Laziness FTW: undefined and error -- * Can leave things as undefined -- sometimes called bottom thisVarIsUndef = undefined soIsThisVar = error \"leaving this undefined for now, fixme later\" -- * Because Haskell is lazy, it won't throw up unless you use them -- * Why might this be useful? -- * Note: This is not how you should raise exceptions in Haskell! -- # Bindings with where clauses -- * Recall that let x = ... in ... can be used to bind variable x within local scope -- * Let can be used whenever you need to create block scope; 'let's are expressions -- * Sometimes you want more flexiblity; therein comes the 'where' clauses: cmpSquare x y | y > z = \"bigger :)\" | y == z = \"same :|\" | y < z = \"smaller :(\" where z = x * x -- * Note that z is in scope of the function there -- * General: where clause associated with function equations or case expressions","title":"Week 2a"},{"location":"lectures/week2a/#lecture-slides","text":"Scope: pdf , key , Haskell: pdf , key ,","title":"Lecture slides"},{"location":"lectures/week2a/#recommended-reading","text":"Textbook: Chapter 7 on Scope, Chapter 5 on Haskell. Philip Guo's JavaScript tutor","title":"Recommended reading"},{"location":"lectures/week2a/#external-sources","text":"If you have not worked with Haskell before, take some time to familiarize yourself with the basics of the language. The chapter above is a good start. But there are many other sources to take advantage of, including: Brent Yorgey's Haskell Basics lectures. Learn You a Haskell for Great Good! is also a good book to read through. A history of Haskell: Being lazy with class is a fantastic read, and there is a similarly engaging talk . A history of Haskell: Being lazy with class is a fantastic read. A Gentle Introduction to Haskell 98 The Haskell 2010 Language","title":"External sources"},{"location":"lectures/week2a/#source-code-used-in-class","text":"Below you'll find the source we used during lecture. You can run these with GHCi (e.g., from Haskell Platform ). module Intro where import Prelude hiding ( Either ( .. )) -- # Definitions and bindings -- * Haskell uses the = sign to declare symbol *bindings*: x = 2 -- * They are called variables, but they are not mutable boxes -- * They are like JS's const (but on steroids) -- x = 3 -- is this allowed? -- * 'let' introduces local bindings (new scope) example0 = let x = 44 -- this \"shadows\" above x z = x - 2 in z * 2 -- what is x here? A: 2, B: 44 -- * Variables are order-independent a = if y then 'a' else 'b' -- we use the y defined below: y = True -- # Essence of programming in Haskell -- * Everything is an expression -- * Expressions evaluate to values -- - What's the diff between expressions and values? -- * Programming in Haskell: substituting equals by equals -- - Lambda calculus for the win! {- example0 = let x = 44 z = x - 2 in z * 2 --> = let z = 44 - 2 in z * 2 --> = (44 - 2) * 2 --> = 42 * 2 --> = 84 -} -- # Every expression has a type -- * E.g., intVal is a word-sized integer intVal :: Int intVal = 31 * ( 42 + 56 ) -- * E.g., ii is an Arbitrarily large integer ii :: Integer ii = 31 * ( 42 + 56000000 * 1000 ) -- * E.g., dbl is a double precision floating point dbl = 3 * ( 4.2 + 5.6 ) -- * E.g., chr is a unicode character chr = 'a' :: Char -- * E.g., str is a String = [Char] str = \"w00t\" :: String listOfInt :: [ Int ] listOfInt = [ 1 , 2 , 3 ] -- * E.g., truth is a Boolean truth = True :: Bool -- ## Some remarks about types {- * We didn't need to add type annotations: Haskell infers types - Inspect types in GHCi with :t - You should generally specify types anyway. Why? * Is this the same thing as not having to specify types in JS? - A: yes, B: no -} -- * Haskell doesn't do any implicit conversions -- - What's the type of ii_x_dbl below: -- ii_x_dbl = ii + dbl :: ??? -- - A: Double, B: Int, C: Type error -- * Arithmetic operators + and * are overloaded (as are some other) ii_add = ii + 33 -- :: ? dbl_add = dbl + 33.0 -- :: ? -- * We'll talk about overloading more in the upcoming classes -- # Functions -- * Functions have \"arrow types\" pos :: Integer -> Bool -- * Function arguments separated by space not (,)'s pos x = x > 0 -- * As in JS, you can just use lambdas instead: gt :: Int -> Int -> Bool gt = \\ x y -> x > y -- \\xy.(x > y) -- * Function application is like in lambda calculus: is33pos = pos 33 -- True -- * How you should NOT think about functions (or expressions): -- - What does this function do? -- * How you should think: what does this mean? Think math! -- * In Haskell, f :: A -> B means: -- - For every element x \u2208 A, -- f(x) = y for some some element y \u2208 B -- or f(x) diverges -- ## Multi-argument functions -- * Functions can take multiple arguments arith :: Int -> Int -> Int -> Int arith x y z = x * ( y + z ) -- * Function appication happens one argument at a time (\"currying\") add x y = x + y five = add 3 2 -- is the same as: (add 3) 2 add3 = add 3 -- :: ??? -- - What's another way to write add3? -- * All Haskell functions take one argument -- - Multi-argument functions just return funtions -- - E.g., the type of add with ()'s added: add :: Integer -> ( Integer -> Integer ) -- - We usually ommit ()'s since -> is right-associative add4Things :: Float -> ( Float -> ( Float -> ( Float -> Float ))) add4Things x y z w = x + y + z + w + ( 1.0 :: Float ) -- # Tuples and lists -- * Haskell has basic support for tuples -- - Constructors: (), (,), (,,), ... -- - E.g., tuples unit = () :: () -- kind of like void tuple2 = ( 3 , 'w' ) :: ( Int , Char ) tuple3 = ( 3 , 'w' , 3.3 ) :: ( Int , Char , Double ) funAdd :: ( Int , Int ) -> Int funAdd ( x , y ) = x + y funAdd35 = funAdd ( 3 , 5 ) -- * Haskell has basic support for homogeneous lists -- - Constructors: (:) | [] myIntList'' = [ 1 , 2 , 3 ] :: [ Int ] -- same as consing things: myIntList''' = 1 : 2 : 3 :[] -- (:) :: Int -> [Int] -> [Int] -- (:) 3 [] == 3:[] == [3] -- * Cons (:) is used to add elements to the list; ++ can be used to -- concatenate lists: concatenatedList = [ 1 , 2 , 3 ] ++ [ 4 , 5 , 6 ] -- * Empty lists myEmptyBoolList :: [ Bool ] myEmptyBoolList = [] myEmptyCharList :: [ Char ] myEmptyCharList = [] -- * Haskell does not have support for heterogenous lists -- - E.g., myHeteroList = [1, 'w'] :: ??? -- # Abstract data types -- * The 'data' keyword declares user-defined data types data PairT = PairC Int Int deriving Show -- means you can print types -- - New type: PairT -- - Value/data constructor: PairC -- - A value of this type encapsulates two Int's myPair :: PairT myPair = PairC 3 4 -- * One type can have multiple constructors data Point = Cartesian Double Double | Polar Double Double deriving Show point1 , point2 :: Point point1 = Cartesian 3.3 2.2 point2 = Polar 0.1 3.14 data Color = Red | Green | Blue | Indigo | Violet deriving Show myRed = Red :: Color -- ## Using ADTs -- * Constructors are like functions, can partially apply: myPair' :: Int -> PairT myPair' = PairC 3 -- * Case expressions can be used to \"de-construct\" values with patterns getX :: PairT -> Int getX pair = case pair of PairC x y -> x -- E.g., convert point to cartesian: toCartesian :: Point -> Point toCartesian point = case point of Polar r theta -> Cartesian ( r * cos theta ) ( r * sin theta ) -- Cartesian x y -> Cartesian x y -- or, less verbose: pt @ ( Cartesian _ _ ) -> pt -- We can define a tiny language with addition and multiplication: data Expr = AddExpr Expr Expr | MulExpr Expr Expr | ConstExpr Int deriving Show eval :: Expr -> Int eval ( ConstExpr n ) = n eval ( AddExpr e1 e2 ) = eval e1 + eval e2 eval ( MulExpr e1 e2 ) = eval e1 * eval e2 -- ## Pattern matching beyond case -- * Can use patterns instead of variables beyond case -- - E.g., when defining functions: toCartesian' :: Point -> Point toCartesian' ( Polar r theta ) = Cartesian ( r * cos theta ) ( r * sin theta ) toCartesian' x = x -- - E.g., in a let block getY pair = let ( PairC _ y ) = pair in y -- * The order of pattern matching matters -- - E.g., What happens if we swap order? factorial' 0 = 1 factorial' n = n * ( factorial' ( n - 1 )) -- * You can alternatively guard definitions: factorial'' n | isLT0 n = 1 factorial'' n | otherwise = n * ( factorial'' ( n - 1 )) -- * Guards are just predicates isLT0 :: Int -> Bool isLT0 = ( <= 0 ) -- ## Recursive datatypes -- * Datatypes can be defined recursively -- - E.g., int list: data IntList = INil | ICons Int IntList deriving Show -- ^^^^^^^ myEmptyIntList = INil :: IntList myIntList = ICons 1 ( ICons 2 ( ICons 3 myEmptyIntList )) :: IntList sumOfIntList :: IntList -> Int sumOfIntList INil = 0 sumOfIntList ( ICons x xs ) = x + ( sumOfIntList xs ) {- Solution: sumOfIntList INil = error \"Empty list\" sumOfIntList (ICons x INil) = x sumOfIntList (ICons x xs) = x + sumOfIntList xs -} six :: Bool six = sumOfIntList myIntList == 6 -- ## Polymorphic datatypes -- * I want a list of Char's or String's or Point's -- - Define separate datatype for each: crazy! We want re-usability! data CharList = CNil | CCons Char CharList deriving Show -- * May want to have functions that work on any kind of lists -- - Solution: parametrized types -- * Types can have parameters (kind of like functions) data List a = Nil | Cons a ( List a ) deriving Show -- ^ ^^^^^^ -- - Here, List itself takes an argument: type variable a. -- - Can use type variable a in constructor -- - Cons and Nil work on any types: myIntList' :: List Int myIntList' = Cons 1 ( Cons 2 ( Cons 3 Nil )) myCharList' :: List Char myCharList' = Cons 'a' ( Cons 'b' ( Cons 'c' Nil )) llength :: List a -> Int llength = undefined {- Solution: llength Nil = 0 llength (Cons x xs) = 1 + llength xs -} myList'len :: Bool myList'len = 3 == llength myIntList' && 3 == llength myCharList' -- ## Polymorphic datatypes with multiple parameters -- * Can have multiple type variables data Either a b = Left a | Right b deriving Show safeDiv :: Int -> Int -> Either String Int safeDiv _ 0 = myErr safeDiv x y = Right $ x ` div ` y -- * What is the type of: --myErr :: ??? myErr = Left \"You can't divide by zero, silly.\" -- # Lazyness -- * Definitions of symbols evauated ony when needed -- - E.g., safe division: safeDiv' x y = let q = div x y -- safe as q never evaluated if y == 0 in if y == 0 then 0 else q -- * Infinite data structures posInts = [ 1 .. ] :: [ Int ] -- * Custom control \"primitives\" -- - E.g., if: if' b x y = case b of True -> x _ -> y -- - E.g., loop forever: forever x = forever x -- - What doe the following mean? exampleF = if' True 3 ( forever 4 ) -- ## Laziness FTW: undefined and error -- * Can leave things as undefined -- sometimes called bottom thisVarIsUndef = undefined soIsThisVar = error \"leaving this undefined for now, fixme later\" -- * Because Haskell is lazy, it won't throw up unless you use them -- * Why might this be useful? -- * Note: This is not how you should raise exceptions in Haskell! -- # Bindings with where clauses -- * Recall that let x = ... in ... can be used to bind variable x within local scope -- * Let can be used whenever you need to create block scope; 'let's are expressions -- * Sometimes you want more flexiblity; therein comes the 'where' clauses: cmpSquare x y | y > z = \"bigger :)\" | y == z = \"same :|\" | y < z = \"smaller :(\" where z = x * x -- * Note that z is in scope of the function there -- * General: where clause associated with function equations or case expressions","title":"Source code used in class"},{"location":"lectures/week2b/","text":"Lecture slides \u00b6 Type systems and type inference: pdf , key , Recommended reading \u00b6 Textbook: new Chapter 6 on types. Type systems for programming languages by Didier R\u00e9my Type tetris \u00b6 In our parametricity explorations we've explored some problems that not only asked you to implement parametric functions, but do so in terms of other parametric functions. This can be quite tricky, but also fun. Below is a worked out example of the hog function from the homework using only the (.) function: -------------------------------------------------------------- -- Simplified example: -------------------------------------------------------------- foo0 :: ( b -> c ) -> ( a -> b ) -> a -> c foo0 f g x = f ( g x ) -- Can be rewritten with the function composition operator (.) as: foo1 :: ( b -> c ) -> ( a -> b ) -> a -> c foo1 f g x = ( f . g ) x -- We can get rid of the x (eta conversion): foo2 :: ( b -> c ) -> ( a -> b ) -> a -> c foo2 f g = f . g -- Let's rewrite it in prefix form now: foo3 :: ( b -> c ) -> ( a -> b ) -> a -> c foo3 f g = ( . ) f g -- Get rid of g (eta again): foo4 :: ( b -> c ) -> ( a -> b ) -> a -> c foo4 f = ( . ) f -- Get rid of f (eta again): foo5 :: ( b -> c ) -> ( a -> b ) -> a -> c foo5 = ( . ) -------------------------------------------------------------- -------------------------------------------------------------- hog :: ( c -> d ) -> ( a -> b -> c ) -> a -> b -> d hog = undefined -- Let's write this with explicit arguments hog0 :: ( c -> d ) -> ( a -> b -> c ) -> a -> b -> d hog0 fCD fABC vA vB = undefined -- Note that we want to produce a d at the end of the day -- What gives us a d? fCD when called with a c -- How do we get a c? Well fABC gives us c when called with an a and b hog1 :: ( c -> d ) -> ( a -> b -> c ) -> a -> b -> d hog1 fCD fABC vA vB = fCD ( fABC vA vB ) -- Another way to look at the type is to write all the parantheses: How can you -- think of this? fABC is almost the thing you want to return. You only need to -- change that c into a d. And the fCD function can be used to do exacly that! hog2 :: ( c -> d ) -> ( a -> ( b -> c )) -> ( a -> ( b -> d )) hog2 fCD fABC vA = ( . ) fCD {- :: (c -> d) -} ( fABC vA {- :: (b -> c) -} ) -- We can now get rid of the vA: hog3 :: ( c -> d ) -> ( a -> ( b -> c )) -> ( a -> ( b -> d )) hog3 fCD fABC = (( . ) fCD ) . fABC -- To get rid of fABC, let's first rewrite it in prefix: hog4 :: ( c -> d ) -> ( a -> ( b -> c )) -> ( a -> ( b -> d )) hog4 fCD fABC = ( . ) (( . ) fCD ) fABC -- Now you can just get rid of fABC (eta conversion): hog5 :: ( c -> d ) -> ( a -> ( b -> c )) -> ( a -> ( b -> d )) hog5 fCD = ( . ) (( . ) fCD ) -- We can now rewrite hog5 by moving fCD to the outside (look at foo1, the (.) -- are just functions like f and g): hog6 :: ( c -> d ) -> ( a -> ( b -> c )) -> ( a -> ( b -> d )) hog6 fCD = (( . ) . ( . )) fCD -- Finally we can just get rid of fCD (eta) and redundant parantheses: hog7 :: ( c -> d ) -> ( a -> ( b -> c )) -> ( a -> ( b -> d )) hog7 = ( . ) . ( . )","title":"Week 2b"},{"location":"lectures/week2b/#lecture-slides","text":"Type systems and type inference: pdf , key ,","title":"Lecture slides"},{"location":"lectures/week2b/#recommended-reading","text":"Textbook: new Chapter 6 on types. Type systems for programming languages by Didier R\u00e9my","title":"Recommended reading"},{"location":"lectures/week2b/#type-tetris","text":"In our parametricity explorations we've explored some problems that not only asked you to implement parametric functions, but do so in terms of other parametric functions. This can be quite tricky, but also fun. Below is a worked out example of the hog function from the homework using only the (.) function: -------------------------------------------------------------- -- Simplified example: -------------------------------------------------------------- foo0 :: ( b -> c ) -> ( a -> b ) -> a -> c foo0 f g x = f ( g x ) -- Can be rewritten with the function composition operator (.) as: foo1 :: ( b -> c ) -> ( a -> b ) -> a -> c foo1 f g x = ( f . g ) x -- We can get rid of the x (eta conversion): foo2 :: ( b -> c ) -> ( a -> b ) -> a -> c foo2 f g = f . g -- Let's rewrite it in prefix form now: foo3 :: ( b -> c ) -> ( a -> b ) -> a -> c foo3 f g = ( . ) f g -- Get rid of g (eta again): foo4 :: ( b -> c ) -> ( a -> b ) -> a -> c foo4 f = ( . ) f -- Get rid of f (eta again): foo5 :: ( b -> c ) -> ( a -> b ) -> a -> c foo5 = ( . ) -------------------------------------------------------------- -------------------------------------------------------------- hog :: ( c -> d ) -> ( a -> b -> c ) -> a -> b -> d hog = undefined -- Let's write this with explicit arguments hog0 :: ( c -> d ) -> ( a -> b -> c ) -> a -> b -> d hog0 fCD fABC vA vB = undefined -- Note that we want to produce a d at the end of the day -- What gives us a d? fCD when called with a c -- How do we get a c? Well fABC gives us c when called with an a and b hog1 :: ( c -> d ) -> ( a -> b -> c ) -> a -> b -> d hog1 fCD fABC vA vB = fCD ( fABC vA vB ) -- Another way to look at the type is to write all the parantheses: How can you -- think of this? fABC is almost the thing you want to return. You only need to -- change that c into a d. And the fCD function can be used to do exacly that! hog2 :: ( c -> d ) -> ( a -> ( b -> c )) -> ( a -> ( b -> d )) hog2 fCD fABC vA = ( . ) fCD {- :: (c -> d) -} ( fABC vA {- :: (b -> c) -} ) -- We can now get rid of the vA: hog3 :: ( c -> d ) -> ( a -> ( b -> c )) -> ( a -> ( b -> d )) hog3 fCD fABC = (( . ) fCD ) . fABC -- To get rid of fABC, let's first rewrite it in prefix: hog4 :: ( c -> d ) -> ( a -> ( b -> c )) -> ( a -> ( b -> d )) hog4 fCD fABC = ( . ) (( . ) fCD ) fABC -- Now you can just get rid of fABC (eta conversion): hog5 :: ( c -> d ) -> ( a -> ( b -> c )) -> ( a -> ( b -> d )) hog5 fCD = ( . ) (( . ) fCD ) -- We can now rewrite hog5 by moving fCD to the outside (look at foo1, the (.) -- are just functions like f and g): hog6 :: ( c -> d ) -> ( a -> ( b -> c )) -> ( a -> ( b -> d )) hog6 fCD = (( . ) . ( . )) fCD -- Finally we can just get rid of fCD (eta) and redundant parantheses: hog7 :: ( c -> d ) -> ( a -> ( b -> c )) -> ( a -> ( b -> d )) hog7 = ( . ) . ( . )","title":"Type tetris"},{"location":"lectures/week3b/","text":"Lecture slides \u00b6 Type classes and type inference: pdf , key , Recommended reading \u00b6 Textbook: new Chapter 7 on type classes. Code snippets \u00b6 Below are the code snippets from class. Show \u00b6 data Tree a = Node ( Tree a ) ( Tree a ) | Leaf a instance Show a => Show ( Tree a ) where show ( Leaf a ) = show a show ( Node lt rt ) = show lt ++ \" / \\\\ \" ++ show rt data Color = Red | Green | Blue | Indigo | Violet deriving Show Eq \u00b6 -- Recall our tiny calculator language data Expr = AddExpr Expr Expr | MulExpr Expr Expr | ConstExpr Int deriving Eq eval :: Expr -> Int eval ( ConstExpr n ) = n eval ( AddExpr e1 e2 ) = eval e1 + eval e2 eval ( MulExpr e1 e2 ) = eval e1 * eval e2 instance Show Expr where show ( ConstExpr i ) = show i show ( AddExpr e1 e2 ) = unwords [ \"(\" , show e1 , \")\" , \"+\" , \"(\" , show e2 , \")\" ] show ( MulExpr e1 e2 ) = unwords [ \"(\" , show e1 , \")\" , \"*\" , \"(\" , show e2 , \")\" ] ex0 :: Expr ex0 = ( AddExpr ( ConstExpr 2 ) ( MulExpr ( ConstExpr 1 ) ( ConstExpr 1 ))) ex1 :: Expr ex1 = ( AddExpr ( ConstExpr 1 ) ( MulExpr ( ConstExpr 1 ) ( ConstExpr 2 ))) eq = ex0 == ex1 -- A: yes, B: no? -- -- instance Eq Expr where -- exp1 == exp2 = eval exp1 == eval exp2 Num \u00b6 module Intro where -- * One type can have multiple constructors data Point = Cartesian Double Double | Polar Double Double deriving Show -- E.g., convert point to cartesian: toCartesian :: Point -> Point toCartesian point = case point of Polar r theta -> Cartesian ( r * cos theta ) ( r * sin theta ) pt @ ( Cartesian _ _ ) -> pt instance Num Point where ( Cartesian x1 y1 ) + ( Cartesian x2 y2 ) = Cartesian ( x1 + x2 ) ( y1 + y2 ) p1 @ ( Polar _ _ ) + p2 @ ( Polar _ _ ) = toCartesian p1 + toCartesian p2 ( Cartesian x1 y1 ) * ( Cartesian x2 y2 ) = Cartesian ( x1 * x2 ) ( y1 * y2 ) p1 * p2 = toCartesian p1 * toCartesian p2 Desugaring type classes to dictionaries \u00b6 Original code, using type classes: module TypeClasses1 where import qualified Prelude import Prelude hiding ( Num ( .. ), Eq ( .. ), Ord ( .. ), map ) -- # Eq class examples class Eq a where ( == ) :: a -> a -> Bool ( == ) x y = not $ x /= y ( /= ) :: a -> a -> Bool ( /= ) x y = not $ x == y instance Eq Bool where ( == ) True True = True ( == ) False False = True ( == ) _ _ = False allEqual :: Eq a => a -> a -> a -> Bool allEqual a b c = ( == ) a b && ( == ) b c instance Eq a => Eq [ a ] where ( == ) [] [] = True ( == ) ( x : xs ) ( y : ys ) = ( == ) x y && ( == ) xs ys --- ^ ^ A: yes , B: no? ( == ) _ _ = False instance ( Eq a , Eq b ) => Eq ( a , b ) where ( == ) ( x1 , y1 ) ( x2 , y2 ) = ( == ) x1 x2 && ( == ) y1 y2 -- # Ord class class Eq a => Ord a where ( < ) :: a -> a -> Bool ( < ) x y = ( <= ) x y && ( /= ) x y ( <= ) :: a -> a -> Bool ( <= ) x y = ( < ) x y || ( == ) x y compare :: Ord a => a -> a -> Ordering compare x y = if x == y then EQ else if x < y then LT else GT -- # Num class -- Our \"primitives\" plusInt :: Int -> Int -> Int plusInt = ( Prelude .+ ) mulInt :: Int -> Int -> Int mulInt = ( Prelude .* ) negInt :: Int -> Int negInt = Prelude . negate integerToInt :: Integer -> Int integerToInt = Prelude . fromInteger -- Dictionary class Num a where ( + ) :: a -> a -> a ( * ) :: a -> a -> a negate :: a -> a square :: Num a => a -> a square x = x * x instance Num Int where ( + ) = plusInt ( * ) = mulInt negate = negInt squares :: ( Num a , Num b ) => a -> b -> ( a , b ) squares x y = ( x * x , y * y ) Desugaring it to dictionaries: module TypeClasses1 where import qualified Prelude import Prelude hiding ( Num ( .. ), Eq ( .. ), Ord ( .. ), map ) -- # Eq class with dictionaries data Eq a = MkEqDict { ( == ) :: a -> a -> Bool , ( /= ) :: a -> a -> Bool } -- instance Eq Bool where ... dEqBool :: Eq Bool dEqBool = MkEqDict { ( == ) = eq , ( /= ) = nEq } where eq True True = True eq False False = True eq _ _ = False nEq x y = not $ eq x y allEqual :: Eq a -> a -> a -> a -> Bool allEqual dict a b c = ( == ) dict a b && ( == ) dict b c -- instance Eq a => Eq [a] where ... dEqList :: Eq a -> Eq [ a ] dEqList elDict = MkEqDict eq nEq where eq [] [] = True eq ( x : xs ) ( y : ys ) = ( == ) elDict x y && eq xs ys eq _ _ = False nEq x y = not $ eq x y -- instance (Eq a, Eq b) => Eq (a, b) where ... dEqPair :: Eq a -> Eq b -> Eq ( a , b ) dEqPair aDict bDict = MkEqDict eq nEq where eq ( x1 , y1 ) ( x2 , y2 ) = ( == ) aDict x1 x2 && ( == ) bDict y1 y2 nEq x y = not $ eq x y -- # Ord class data Ord a = MkOrd { ( <= ) :: a -> a -> Bool , eqD :: Eq a } compare :: Ord a -> a -> a -> Ordering compare d x y = undefined -- # Num class -- Our \"primitives\" plusInt :: Int -> Int -> Int plusInt = ( Prelude .+ ) mulInt :: Int -> Int -> Int mulInt = ( Prelude .* ) negInt :: Int -> Int negInt = Prelude . negate integerToInt :: Integer -> Int integerToInt = Prelude . fromInteger -- Dictionary data Num a = MkNumDict { ( + ) :: a -> a -> a , ( * ) :: a -> a -> a , negate :: a -> a } -- square :: Num a => a -> a square :: Num a -> a -> a square = undefined dNumInt :: Num Int dNumInt = MkNumDict plusInt mulInt negInt -- squares :: (Num a, Num b) => a -> b -> (a, b) squares :: Num a -> Num b -> a -> b -> ( a , b ) squares dx dy x y = undefined A more complex example with type constructors \u00b6 {-# LANGUAGE InstanceSigs #-} module HasMap where import Prelude hiding ( map ) mapList :: ( a -> b ) -> [ a ] -> [ b ] mapList f [] = [] mapList f ( x : xs ) = f x : mapList f xs mapMaybe :: ( a -> b ) -> Maybe a -> Maybe b mapMaybe f Nothing = Nothing mapMaybe f ( Just x ) = Just ( f x ) data Tree a = Leaf a | Node ( Tree a ) ( Tree a ) mapTree :: ( a -> b ) -> Tree a -> Tree b mapTree f ( Leaf x ) = Leaf ( f x ) mapTree f ( Node t1 t2 ) = Node ( mapTree f t1 ) ( mapTree f t2 ) class HasMap g where map :: ( a -> b ) -> g a -> g b instance HasMap [] where map :: ( a -> b ) -> [ a ] -> [ b ] map f [] = [] map f ( x : xs ) = f x : map f xs instance HasMap Maybe where map = mapMaybe instance HasMap Tree where map = mapTree","title":"Week 3b"},{"location":"lectures/week3b/#lecture-slides","text":"Type classes and type inference: pdf , key ,","title":"Lecture slides"},{"location":"lectures/week3b/#recommended-reading","text":"Textbook: new Chapter 7 on type classes.","title":"Recommended reading"},{"location":"lectures/week3b/#code-snippets","text":"Below are the code snippets from class.","title":"Code snippets"},{"location":"lectures/week3b/#show","text":"data Tree a = Node ( Tree a ) ( Tree a ) | Leaf a instance Show a => Show ( Tree a ) where show ( Leaf a ) = show a show ( Node lt rt ) = show lt ++ \" / \\\\ \" ++ show rt data Color = Red | Green | Blue | Indigo | Violet deriving Show","title":"Show"},{"location":"lectures/week3b/#eq","text":"-- Recall our tiny calculator language data Expr = AddExpr Expr Expr | MulExpr Expr Expr | ConstExpr Int deriving Eq eval :: Expr -> Int eval ( ConstExpr n ) = n eval ( AddExpr e1 e2 ) = eval e1 + eval e2 eval ( MulExpr e1 e2 ) = eval e1 * eval e2 instance Show Expr where show ( ConstExpr i ) = show i show ( AddExpr e1 e2 ) = unwords [ \"(\" , show e1 , \")\" , \"+\" , \"(\" , show e2 , \")\" ] show ( MulExpr e1 e2 ) = unwords [ \"(\" , show e1 , \")\" , \"*\" , \"(\" , show e2 , \")\" ] ex0 :: Expr ex0 = ( AddExpr ( ConstExpr 2 ) ( MulExpr ( ConstExpr 1 ) ( ConstExpr 1 ))) ex1 :: Expr ex1 = ( AddExpr ( ConstExpr 1 ) ( MulExpr ( ConstExpr 1 ) ( ConstExpr 2 ))) eq = ex0 == ex1 -- A: yes, B: no? -- -- instance Eq Expr where -- exp1 == exp2 = eval exp1 == eval exp2","title":"Eq"},{"location":"lectures/week3b/#num","text":"module Intro where -- * One type can have multiple constructors data Point = Cartesian Double Double | Polar Double Double deriving Show -- E.g., convert point to cartesian: toCartesian :: Point -> Point toCartesian point = case point of Polar r theta -> Cartesian ( r * cos theta ) ( r * sin theta ) pt @ ( Cartesian _ _ ) -> pt instance Num Point where ( Cartesian x1 y1 ) + ( Cartesian x2 y2 ) = Cartesian ( x1 + x2 ) ( y1 + y2 ) p1 @ ( Polar _ _ ) + p2 @ ( Polar _ _ ) = toCartesian p1 + toCartesian p2 ( Cartesian x1 y1 ) * ( Cartesian x2 y2 ) = Cartesian ( x1 * x2 ) ( y1 * y2 ) p1 * p2 = toCartesian p1 * toCartesian p2","title":"Num"},{"location":"lectures/week3b/#desugaring-type-classes-to-dictionaries","text":"Original code, using type classes: module TypeClasses1 where import qualified Prelude import Prelude hiding ( Num ( .. ), Eq ( .. ), Ord ( .. ), map ) -- # Eq class examples class Eq a where ( == ) :: a -> a -> Bool ( == ) x y = not $ x /= y ( /= ) :: a -> a -> Bool ( /= ) x y = not $ x == y instance Eq Bool where ( == ) True True = True ( == ) False False = True ( == ) _ _ = False allEqual :: Eq a => a -> a -> a -> Bool allEqual a b c = ( == ) a b && ( == ) b c instance Eq a => Eq [ a ] where ( == ) [] [] = True ( == ) ( x : xs ) ( y : ys ) = ( == ) x y && ( == ) xs ys --- ^ ^ A: yes , B: no? ( == ) _ _ = False instance ( Eq a , Eq b ) => Eq ( a , b ) where ( == ) ( x1 , y1 ) ( x2 , y2 ) = ( == ) x1 x2 && ( == ) y1 y2 -- # Ord class class Eq a => Ord a where ( < ) :: a -> a -> Bool ( < ) x y = ( <= ) x y && ( /= ) x y ( <= ) :: a -> a -> Bool ( <= ) x y = ( < ) x y || ( == ) x y compare :: Ord a => a -> a -> Ordering compare x y = if x == y then EQ else if x < y then LT else GT -- # Num class -- Our \"primitives\" plusInt :: Int -> Int -> Int plusInt = ( Prelude .+ ) mulInt :: Int -> Int -> Int mulInt = ( Prelude .* ) negInt :: Int -> Int negInt = Prelude . negate integerToInt :: Integer -> Int integerToInt = Prelude . fromInteger -- Dictionary class Num a where ( + ) :: a -> a -> a ( * ) :: a -> a -> a negate :: a -> a square :: Num a => a -> a square x = x * x instance Num Int where ( + ) = plusInt ( * ) = mulInt negate = negInt squares :: ( Num a , Num b ) => a -> b -> ( a , b ) squares x y = ( x * x , y * y ) Desugaring it to dictionaries: module TypeClasses1 where import qualified Prelude import Prelude hiding ( Num ( .. ), Eq ( .. ), Ord ( .. ), map ) -- # Eq class with dictionaries data Eq a = MkEqDict { ( == ) :: a -> a -> Bool , ( /= ) :: a -> a -> Bool } -- instance Eq Bool where ... dEqBool :: Eq Bool dEqBool = MkEqDict { ( == ) = eq , ( /= ) = nEq } where eq True True = True eq False False = True eq _ _ = False nEq x y = not $ eq x y allEqual :: Eq a -> a -> a -> a -> Bool allEqual dict a b c = ( == ) dict a b && ( == ) dict b c -- instance Eq a => Eq [a] where ... dEqList :: Eq a -> Eq [ a ] dEqList elDict = MkEqDict eq nEq where eq [] [] = True eq ( x : xs ) ( y : ys ) = ( == ) elDict x y && eq xs ys eq _ _ = False nEq x y = not $ eq x y -- instance (Eq a, Eq b) => Eq (a, b) where ... dEqPair :: Eq a -> Eq b -> Eq ( a , b ) dEqPair aDict bDict = MkEqDict eq nEq where eq ( x1 , y1 ) ( x2 , y2 ) = ( == ) aDict x1 x2 && ( == ) bDict y1 y2 nEq x y = not $ eq x y -- # Ord class data Ord a = MkOrd { ( <= ) :: a -> a -> Bool , eqD :: Eq a } compare :: Ord a -> a -> a -> Ordering compare d x y = undefined -- # Num class -- Our \"primitives\" plusInt :: Int -> Int -> Int plusInt = ( Prelude .+ ) mulInt :: Int -> Int -> Int mulInt = ( Prelude .* ) negInt :: Int -> Int negInt = Prelude . negate integerToInt :: Integer -> Int integerToInt = Prelude . fromInteger -- Dictionary data Num a = MkNumDict { ( + ) :: a -> a -> a , ( * ) :: a -> a -> a , negate :: a -> a } -- square :: Num a => a -> a square :: Num a -> a -> a square = undefined dNumInt :: Num Int dNumInt = MkNumDict plusInt mulInt negInt -- squares :: (Num a, Num b) => a -> b -> (a, b) squares :: Num a -> Num b -> a -> b -> ( a , b ) squares dx dy x y = undefined","title":"Desugaring type classes to dictionaries"},{"location":"lectures/week3b/#a-more-complex-example-with-type-constructors","text":"{-# LANGUAGE InstanceSigs #-} module HasMap where import Prelude hiding ( map ) mapList :: ( a -> b ) -> [ a ] -> [ b ] mapList f [] = [] mapList f ( x : xs ) = f x : mapList f xs mapMaybe :: ( a -> b ) -> Maybe a -> Maybe b mapMaybe f Nothing = Nothing mapMaybe f ( Just x ) = Just ( f x ) data Tree a = Leaf a | Node ( Tree a ) ( Tree a ) mapTree :: ( a -> b ) -> Tree a -> Tree b mapTree f ( Leaf x ) = Leaf ( f x ) mapTree f ( Node t1 t2 ) = Node ( mapTree f t1 ) ( mapTree f t2 ) class HasMap g where map :: ( a -> b ) -> g a -> g b instance HasMap [] where map :: ( a -> b ) -> [ a ] -> [ b ] map f [] = [] map f ( x : xs ) = f x : map f xs instance HasMap Maybe where map = mapMaybe instance HasMap Tree where map = mapTree","title":"A more complex example with type constructors"},{"location":"lectures/week4a/","text":"Lecture slides \u00b6 Objects: pdf , key , Recommended reading \u00b6 Textbook: Chapters 10, 11. Object-oriented programming: Some history, and challenges for the next fifty years by Black. The Early History Of Smalltalk by Kay.","title":"Week 4a"},{"location":"lectures/week4a/#lecture-slides","text":"Objects: pdf , key ,","title":"Lecture slides"},{"location":"lectures/week4a/#recommended-reading","text":"Textbook: Chapters 10, 11. Object-oriented programming: Some history, and challenges for the next fifty years by Black. The Early History Of Smalltalk by Kay.","title":"Recommended reading"},{"location":"lectures/week4b/","text":"Lecture slides \u00b6 Objects, continued from Week 6 . C++ and subtyping: pdf , key , Recommended reading \u00b6 Object chapters from Week 6 . Textbook: Chapters 11, 12","title":"Week 4b"},{"location":"lectures/week4b/#lecture-slides","text":"Objects, continued from Week 6 . C++ and subtyping: pdf , key ,","title":"Lecture slides"},{"location":"lectures/week4b/#recommended-reading","text":"Object chapters from Week 6 . Textbook: Chapters 11, 12","title":"Recommended reading"},{"location":"lectures/week5a/","text":"Lecture slides \u00b6 Control flow, continuations, monads: pdf , key . Recommended reading \u00b6 Textbook: Sections 8.1, 8.3 By example: Continuation-passing style in JavaScript by Matt Might Tackling the Awkward Squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell by Simon Peyton Jones","title":"Week 5a"},{"location":"lectures/week5a/#lecture-slides","text":"Control flow, continuations, monads: pdf , key .","title":"Lecture slides"},{"location":"lectures/week5a/#recommended-reading","text":"Textbook: Sections 8.1, 8.3 By example: Continuation-passing style in JavaScript by Matt Might Tackling the Awkward Squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell by Simon Peyton Jones","title":"Recommended reading"},{"location":"lectures/week9/","text":"Lecture slides \u00b6 Monads, continued from Week 8 . The videos go into the desugarion of IO action into Worlds -- watch them! Intro to constant-time: pdf , key , Recommended reading \u00b6 Monad sources from Week 8 . Why Constant-Time Crypto by Thomas Pornin Remote Timing Attacks are Practical by David Brumley and Dan Boneh Code snippets \u00b6 Implementing wc in Haskell \u00b6 module Main ( main ) where import System.Environment getFilename :: IO String getFilename = do args <- getArgs case args of ( arg : _ ) -> return arg _ -> fail \"missing arg\" main :: IO () main = do fname <- getFilename putStrLn $ \"processing \" ++ fname contents <- readFile fname putStrLn $ \"lines: \" ++ show ( length $ lines contents ) putStrLn $ \"words: \" ++ show ( length $ words contents ) Functor-like type class \u00b6 {-# LANGUAGE InstanceSigs #-} module HasMap where import Prelude hiding ( map ) mapList :: ( a -> b ) -> [ a ] -> [ b ] mapList f [] = [] mapList f ( x : xs ) = f x : mapList f xs mapMaybe :: ( a -> b ) -> Maybe a -> Maybe b mapMaybe f Nothing = Nothing mapMaybe f ( Just x ) = Just ( f x ) data Tree a = Leaf a | Node ( Tree a ) ( Tree a ) mapTree :: ( a -> b ) -> Tree a -> Tree b mapTree f ( Leaf x ) = Leaf ( f x ) mapTree f ( Node t1 t2 ) = Node ( mapTree f t1 ) ( mapTree f t2 ) class HasMap g where map :: ( a -> b ) -> g a -> g b instance HasMap [] where map :: ( a -> b ) -> [ a ] -> [ b ] map f [] = [] map f ( x : xs ) = f x : map f xs instance HasMap Maybe where map = mapMaybe instance HasMap Tree where map = mapTree","title":"Home"},{"location":"lectures/week9/#lecture-slides","text":"Monads, continued from Week 8 . The videos go into the desugarion of IO action into Worlds -- watch them! Intro to constant-time: pdf , key ,","title":"Lecture slides"},{"location":"lectures/week9/#recommended-reading","text":"Monad sources from Week 8 . Why Constant-Time Crypto by Thomas Pornin Remote Timing Attacks are Practical by David Brumley and Dan Boneh","title":"Recommended reading"},{"location":"lectures/week9/#code-snippets","text":"","title":"Code snippets"},{"location":"lectures/week9/#implementing-wc-in-haskell","text":"module Main ( main ) where import System.Environment getFilename :: IO String getFilename = do args <- getArgs case args of ( arg : _ ) -> return arg _ -> fail \"missing arg\" main :: IO () main = do fname <- getFilename putStrLn $ \"processing \" ++ fname contents <- readFile fname putStrLn $ \"lines: \" ++ show ( length $ lines contents ) putStrLn $ \"words: \" ++ show ( length $ words contents )","title":"Implementing wc in Haskell"},{"location":"lectures/week9/#functor-like-type-class","text":"{-# LANGUAGE InstanceSigs #-} module HasMap where import Prelude hiding ( map ) mapList :: ( a -> b ) -> [ a ] -> [ b ] mapList f [] = [] mapList f ( x : xs ) = f x : mapList f xs mapMaybe :: ( a -> b ) -> Maybe a -> Maybe b mapMaybe f Nothing = Nothing mapMaybe f ( Just x ) = Just ( f x ) data Tree a = Leaf a | Node ( Tree a ) ( Tree a ) mapTree :: ( a -> b ) -> Tree a -> Tree b mapTree f ( Leaf x ) = Leaf ( f x ) mapTree f ( Node t1 t2 ) = Node ( mapTree f t1 ) ( mapTree f t2 ) class HasMap g where map :: ( a -> b ) -> g a -> g b instance HasMap [] where map :: ( a -> b ) -> [ a ] -> [ b ] map f [] = [] map f ( x : xs ) = f x : map f xs instance HasMap Maybe where map = mapMaybe instance HasMap Tree where map = mapTree","title":"Functor-like type class"},{"location":"notes/js_nono/","text":"Below are code snippets that illustrate some of the flexible features of JavaScript and how they can introduce unexpected/unintuitive behavior. There are many more; see Appendix B of Crockford's JavaScript: The Good Parts . Please note that there are useful, positive sides of most of these; every language design/implementation decision is a trade-off. Automatic semicolon insertion \u00b6 function f () { return 3 ; } function g () { return 3 ; } console . log ( f ()); // ?? console . log ( g ()); // ?? Eval \u00b6 JavaScript's eval function can be used to load and execute new code at runtime. This is generally considered a bad/dangerous idea, but nevertheless useful in some cases. Beyond security implications (mostly a concern in the browser since eval can easily be leveraged to carry out XSS attacks ), however the behavior of eval differs when you call it directly or indirectly. This difference was introduced in the name of performance (arguably okay since you should not be using eval very much, but still not great.) global . x = 33 ; { const x = 44 ; const ev = eval ; console . log ( eval ( \"x\" )); // ?? console . log ( ev ( \"x\" )); // ?? } Implicit casting \u00b6 See the sarcastic WAT video. Monkeypatching \u00b6 Because JavaScript lets you modify arbitrary objects and their prototypes, running untrusted code safely is extremely difficult to do. (If you're interested in this, come talk to me; this is some of my research). See some examples here on global object poisoning. Here is the simplest: // suppose add was exposed by a third-party library function add ( x , y ) { // Poison the Object prototype by redefining toString, // which is called when objects are implicitly casted to // strings. The modified function modifies the object (this), by // setting name to 'mud'; Object . prototype . toString = function () { var name = this . name ; this . name = 'mud' ; return 'HA ' + name + '. IM STEALIN UR CODEZ!' ; }; return x + y ; } var o = { name : 'Bingo' }; console . log ( add ( 3 , 4 )); // calling add poisoned Object.prototype console . log ( '' + o ); console . log ( 'Your name is now ' + o . name );","title":"JavaScript No No's"},{"location":"notes/js_nono/#automatic-semicolon-insertion","text":"function f () { return 3 ; } function g () { return 3 ; } console . log ( f ()); // ?? console . log ( g ()); // ??","title":"Automatic semicolon insertion"},{"location":"notes/js_nono/#eval","text":"JavaScript's eval function can be used to load and execute new code at runtime. This is generally considered a bad/dangerous idea, but nevertheless useful in some cases. Beyond security implications (mostly a concern in the browser since eval can easily be leveraged to carry out XSS attacks ), however the behavior of eval differs when you call it directly or indirectly. This difference was introduced in the name of performance (arguably okay since you should not be using eval very much, but still not great.) global . x = 33 ; { const x = 44 ; const ev = eval ; console . log ( eval ( \"x\" )); // ?? console . log ( ev ( \"x\" )); // ?? }","title":"Eval"},{"location":"notes/js_nono/#implicit-casting","text":"See the sarcastic WAT video.","title":"Implicit casting"},{"location":"notes/js_nono/#monkeypatching","text":"Because JavaScript lets you modify arbitrary objects and their prototypes, running untrusted code safely is extremely difficult to do. (If you're interested in this, come talk to me; this is some of my research). See some examples here on global object poisoning. Here is the simplest: // suppose add was exposed by a third-party library function add ( x , y ) { // Poison the Object prototype by redefining toString, // which is called when objects are implicitly casted to // strings. The modified function modifies the object (this), by // setting name to 'mud'; Object . prototype . toString = function () { var name = this . name ; this . name = 'mud' ; return 'HA ' + name + '. IM STEALIN UR CODEZ!' ; }; return x + y ; } var o = { name : 'Bingo' }; console . log ( add ( 3 , 4 )); // calling add poisoned Object.prototype console . log ( '' + o ); console . log ( 'Your name is now ' + o . name );","title":"Monkeypatching"}]}